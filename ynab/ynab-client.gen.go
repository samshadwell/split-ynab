// Package ynab provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.0.0 DO NOT EDIT.
package ynab

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerScopes = "bearer.Scopes"
)

// Defines values for AccountType.
const (
	AutoLoan       AccountType = "autoLoan"
	Cash           AccountType = "cash"
	Checking       AccountType = "checking"
	CreditCard     AccountType = "creditCard"
	LineOfCredit   AccountType = "lineOfCredit"
	MedicalDebt    AccountType = "medicalDebt"
	Mortgage       AccountType = "mortgage"
	OtherAsset     AccountType = "otherAsset"
	OtherDebt      AccountType = "otherDebt"
	OtherLiability AccountType = "otherLiability"
	PersonalLoan   AccountType = "personalLoan"
	Savings        AccountType = "savings"
	StudentLoan    AccountType = "studentLoan"
)

// Defines values for CategoryGoalType.
const (
	CategoryGoalTypeDEBT CategoryGoalType = "DEBT"
	CategoryGoalTypeMF   CategoryGoalType = "MF"
	CategoryGoalTypeNEED CategoryGoalType = "NEED"
	CategoryGoalTypeNil  CategoryGoalType = "<nil>"
	CategoryGoalTypeTB   CategoryGoalType = "TB"
	CategoryGoalTypeTBD  CategoryGoalType = "TBD"
)

// Defines values for HybridTransactionDebtTransactionType.
const (
	HybridTransactionDebtTransactionTypeBalanceAdjustment HybridTransactionDebtTransactionType = "balanceAdjustment"
	HybridTransactionDebtTransactionTypeCharge            HybridTransactionDebtTransactionType = "charge"
	HybridTransactionDebtTransactionTypeCredit            HybridTransactionDebtTransactionType = "credit"
	HybridTransactionDebtTransactionTypeEscrow            HybridTransactionDebtTransactionType = "escrow"
	HybridTransactionDebtTransactionTypeFee               HybridTransactionDebtTransactionType = "fee"
	HybridTransactionDebtTransactionTypeInterest          HybridTransactionDebtTransactionType = "interest"
	HybridTransactionDebtTransactionTypeNil               HybridTransactionDebtTransactionType = "<nil>"
	HybridTransactionDebtTransactionTypePayment           HybridTransactionDebtTransactionType = "payment"
	HybridTransactionDebtTransactionTypeRefund            HybridTransactionDebtTransactionType = "refund"
)

// Defines values for HybridTransactionType.
const (
	Subtransaction HybridTransactionType = "subtransaction"
	Transaction    HybridTransactionType = "transaction"
)

// Defines values for ScheduledTransactionDetailFrequency.
const (
	ScheduledTransactionDetailFrequencyDaily           ScheduledTransactionDetailFrequency = "daily"
	ScheduledTransactionDetailFrequencyEvery3Months    ScheduledTransactionDetailFrequency = "every3Months"
	ScheduledTransactionDetailFrequencyEvery4Months    ScheduledTransactionDetailFrequency = "every4Months"
	ScheduledTransactionDetailFrequencyEvery4Weeks     ScheduledTransactionDetailFrequency = "every4Weeks"
	ScheduledTransactionDetailFrequencyEveryOtherMonth ScheduledTransactionDetailFrequency = "everyOtherMonth"
	ScheduledTransactionDetailFrequencyEveryOtherWeek  ScheduledTransactionDetailFrequency = "everyOtherWeek"
	ScheduledTransactionDetailFrequencyEveryOtherYear  ScheduledTransactionDetailFrequency = "everyOtherYear"
	ScheduledTransactionDetailFrequencyMonthly         ScheduledTransactionDetailFrequency = "monthly"
	ScheduledTransactionDetailFrequencyNever           ScheduledTransactionDetailFrequency = "never"
	ScheduledTransactionDetailFrequencyTwiceAMonth     ScheduledTransactionDetailFrequency = "twiceAMonth"
	ScheduledTransactionDetailFrequencyTwiceAYear      ScheduledTransactionDetailFrequency = "twiceAYear"
	ScheduledTransactionDetailFrequencyWeekly          ScheduledTransactionDetailFrequency = "weekly"
	ScheduledTransactionDetailFrequencyYearly          ScheduledTransactionDetailFrequency = "yearly"
)

// Defines values for ScheduledTransactionSummaryFrequency.
const (
	ScheduledTransactionSummaryFrequencyDaily           ScheduledTransactionSummaryFrequency = "daily"
	ScheduledTransactionSummaryFrequencyEvery3Months    ScheduledTransactionSummaryFrequency = "every3Months"
	ScheduledTransactionSummaryFrequencyEvery4Months    ScheduledTransactionSummaryFrequency = "every4Months"
	ScheduledTransactionSummaryFrequencyEvery4Weeks     ScheduledTransactionSummaryFrequency = "every4Weeks"
	ScheduledTransactionSummaryFrequencyEveryOtherMonth ScheduledTransactionSummaryFrequency = "everyOtherMonth"
	ScheduledTransactionSummaryFrequencyEveryOtherWeek  ScheduledTransactionSummaryFrequency = "everyOtherWeek"
	ScheduledTransactionSummaryFrequencyEveryOtherYear  ScheduledTransactionSummaryFrequency = "everyOtherYear"
	ScheduledTransactionSummaryFrequencyMonthly         ScheduledTransactionSummaryFrequency = "monthly"
	ScheduledTransactionSummaryFrequencyNever           ScheduledTransactionSummaryFrequency = "never"
	ScheduledTransactionSummaryFrequencyTwiceAMonth     ScheduledTransactionSummaryFrequency = "twiceAMonth"
	ScheduledTransactionSummaryFrequencyTwiceAYear      ScheduledTransactionSummaryFrequency = "twiceAYear"
	ScheduledTransactionSummaryFrequencyWeekly          ScheduledTransactionSummaryFrequency = "weekly"
	ScheduledTransactionSummaryFrequencyYearly          ScheduledTransactionSummaryFrequency = "yearly"
)

// Defines values for TransactionClearedStatus.
const (
	Cleared    TransactionClearedStatus = "cleared"
	Reconciled TransactionClearedStatus = "reconciled"
	Uncleared  TransactionClearedStatus = "uncleared"
)

// Defines values for TransactionDetailDebtTransactionType.
const (
	TransactionDetailDebtTransactionTypeBalanceAdjustment TransactionDetailDebtTransactionType = "balanceAdjustment"
	TransactionDetailDebtTransactionTypeCharge            TransactionDetailDebtTransactionType = "charge"
	TransactionDetailDebtTransactionTypeCredit            TransactionDetailDebtTransactionType = "credit"
	TransactionDetailDebtTransactionTypeEscrow            TransactionDetailDebtTransactionType = "escrow"
	TransactionDetailDebtTransactionTypeFee               TransactionDetailDebtTransactionType = "fee"
	TransactionDetailDebtTransactionTypeInterest          TransactionDetailDebtTransactionType = "interest"
	TransactionDetailDebtTransactionTypeNil               TransactionDetailDebtTransactionType = "<nil>"
	TransactionDetailDebtTransactionTypePayment           TransactionDetailDebtTransactionType = "payment"
	TransactionDetailDebtTransactionTypeRefund            TransactionDetailDebtTransactionType = "refund"
)

// Defines values for TransactionFlagColor.
const (
	TransactionFlagColorBlue   TransactionFlagColor = "blue"
	TransactionFlagColorGreen  TransactionFlagColor = "green"
	TransactionFlagColorNil    TransactionFlagColor = "<nil>"
	TransactionFlagColorOrange TransactionFlagColor = "orange"
	TransactionFlagColorPurple TransactionFlagColor = "purple"
	TransactionFlagColorRed    TransactionFlagColor = "red"
	TransactionFlagColorYellow TransactionFlagColor = "yellow"
)

// Defines values for TransactionSummaryDebtTransactionType.
const (
	BalanceAdjustment TransactionSummaryDebtTransactionType = "balanceAdjustment"
	Charge            TransactionSummaryDebtTransactionType = "charge"
	Credit            TransactionSummaryDebtTransactionType = "credit"
	Escrow            TransactionSummaryDebtTransactionType = "escrow"
	Fee               TransactionSummaryDebtTransactionType = "fee"
	Interest          TransactionSummaryDebtTransactionType = "interest"
	Nil               TransactionSummaryDebtTransactionType = "<nil>"
	Payment           TransactionSummaryDebtTransactionType = "payment"
	Refund            TransactionSummaryDebtTransactionType = "refund"
)

// Defines values for GetTransactionsByAccountParamsType.
const (
	GetTransactionsByAccountParamsTypeUnapproved    GetTransactionsByAccountParamsType = "unapproved"
	GetTransactionsByAccountParamsTypeUncategorized GetTransactionsByAccountParamsType = "uncategorized"
)

// Defines values for GetTransactionsByCategoryParamsType.
const (
	GetTransactionsByCategoryParamsTypeUnapproved    GetTransactionsByCategoryParamsType = "unapproved"
	GetTransactionsByCategoryParamsTypeUncategorized GetTransactionsByCategoryParamsType = "uncategorized"
)

// Defines values for GetTransactionsByPayeeParamsType.
const (
	GetTransactionsByPayeeParamsTypeUnapproved    GetTransactionsByPayeeParamsType = "unapproved"
	GetTransactionsByPayeeParamsTypeUncategorized GetTransactionsByPayeeParamsType = "uncategorized"
)

// Defines values for GetTransactionsParamsType.
const (
	GetTransactionsParamsTypeUnapproved    GetTransactionsParamsType = "unapproved"
	GetTransactionsParamsTypeUncategorized GetTransactionsParamsType = "uncategorized"
)

// Account defines model for Account.
type Account struct {
	// Balance The current balance of the account in milliunits format
	Balance int64 `json:"balance"`

	// ClearedBalance The current cleared balance of the account in milliunits format
	ClearedBalance int64 `json:"cleared_balance"`

	// Closed Whether this account is closed or not
	Closed              bool                      `json:"closed"`
	DebtEscrowAmounts   *LoanAccountPeriodicValue `json:"debt_escrow_amounts"`
	DebtInterestRates   *LoanAccountPeriodicValue `json:"debt_interest_rates"`
	DebtMinimumPayments *LoanAccountPeriodicValue `json:"debt_minimum_payments"`

	// DebtOriginalBalance The original debt/loan account balance, specified in milliunits format.
	DebtOriginalBalance *int64 `json:"debt_original_balance"`

	// Deleted Whether or not the account has been deleted.  Deleted accounts will only be included in delta requests.
	Deleted bool `json:"deleted"`

	// DirectImportInError If an account linked to a financial institution (direct_import_linked=true) and the linked connection is not in a healthy state, this will be true.
	DirectImportInError *bool `json:"direct_import_in_error,omitempty"`

	// DirectImportLinked Whether or not the account is linked to a financial institution for automatic transaction import.
	DirectImportLinked *bool              `json:"direct_import_linked,omitempty"`
	Id                 openapi_types.UUID `json:"id"`

	// LastReconciledAt A date/time specifying when the account was last reconciled.
	LastReconciledAt *time.Time `json:"last_reconciled_at"`
	Name             string     `json:"name"`
	Note             *string    `json:"note"`

	// OnBudget Whether this account is on budget or not
	OnBudget bool `json:"on_budget"`

	// TransferPayeeId The payee id which should be used when transferring to this account
	TransferPayeeId *openapi_types.UUID `json:"transfer_payee_id"`

	// Type The type of account
	Type AccountType `json:"type"`

	// UnclearedBalance The current uncleared balance of the account in milliunits format
	UnclearedBalance int64 `json:"uncleared_balance"`
}

// AccountResponse defines model for AccountResponse.
type AccountResponse struct {
	Data struct {
		Account Account `json:"account"`
	} `json:"data"`
}

// AccountType The type of account
type AccountType string

// AccountsResponse defines model for AccountsResponse.
type AccountsResponse struct {
	Data struct {
		Accounts []Account `json:"accounts"`

		// ServerKnowledge The knowledge of the server
		ServerKnowledge int64 `json:"server_knowledge"`
	} `json:"data"`
}

// BudgetDetail defines model for BudgetDetail.
type BudgetDetail struct {
	Accounts       *[]Account       `json:"accounts,omitempty"`
	Categories     *[]Category      `json:"categories,omitempty"`
	CategoryGroups *[]CategoryGroup `json:"category_groups,omitempty"`

	// CurrencyFormat The currency format setting for the budget.  In some cases the format will not be available and will be specified as null.
	CurrencyFormat *CurrencyFormat `json:"currency_format"`

	// DateFormat The date format setting for the budget.  In some cases the format will not be available and will be specified as null.
	DateFormat *DateFormat `json:"date_format"`

	// FirstMonth The earliest budget month
	FirstMonth *openapi_types.Date `json:"first_month,omitempty"`
	Id         openapi_types.UUID  `json:"id"`

	// LastModifiedOn The last time any changes were made to the budget from either a web or mobile client
	LastModifiedOn *time.Time `json:"last_modified_on,omitempty"`

	// LastMonth The latest budget month
	LastMonth                *openapi_types.Date            `json:"last_month,omitempty"`
	Months                   *[]MonthDetail                 `json:"months,omitempty"`
	Name                     string                         `json:"name"`
	PayeeLocations           *[]PayeeLocation               `json:"payee_locations,omitempty"`
	Payees                   *[]Payee                       `json:"payees,omitempty"`
	ScheduledSubtransactions *[]ScheduledSubTransaction     `json:"scheduled_subtransactions,omitempty"`
	ScheduledTransactions    *[]ScheduledTransactionSummary `json:"scheduled_transactions,omitempty"`
	Subtransactions          *[]SubTransaction              `json:"subtransactions,omitempty"`
	Transactions             *[]TransactionSummary          `json:"transactions,omitempty"`
}

// BudgetDetailResponse defines model for BudgetDetailResponse.
type BudgetDetailResponse struct {
	Data struct {
		Budget BudgetDetail `json:"budget"`

		// ServerKnowledge The knowledge of the server
		ServerKnowledge int64 `json:"server_knowledge"`
	} `json:"data"`
}

// BudgetSettings defines model for BudgetSettings.
type BudgetSettings struct {
	// CurrencyFormat The currency format setting for the budget.  In some cases the format will not be available and will be specified as null.
	CurrencyFormat *CurrencyFormat `json:"currency_format"`

	// DateFormat The date format setting for the budget.  In some cases the format will not be available and will be specified as null.
	DateFormat *DateFormat `json:"date_format"`
}

// BudgetSettingsResponse defines model for BudgetSettingsResponse.
type BudgetSettingsResponse struct {
	Data struct {
		Settings BudgetSettings `json:"settings"`
	} `json:"data"`
}

// BudgetSummary defines model for BudgetSummary.
type BudgetSummary struct {
	// Accounts The budget accounts (only included if `include_accounts=true` specified as query parameter)
	Accounts *[]Account `json:"accounts,omitempty"`

	// CurrencyFormat The currency format setting for the budget.  In some cases the format will not be available and will be specified as null.
	CurrencyFormat *CurrencyFormat `json:"currency_format"`

	// DateFormat The date format setting for the budget.  In some cases the format will not be available and will be specified as null.
	DateFormat *DateFormat `json:"date_format"`

	// FirstMonth The earliest budget month
	FirstMonth *openapi_types.Date `json:"first_month,omitempty"`
	Id         openapi_types.UUID  `json:"id"`

	// LastModifiedOn The last time any changes were made to the budget from either a web or mobile client
	LastModifiedOn *time.Time `json:"last_modified_on,omitempty"`

	// LastMonth The latest budget month
	LastMonth *openapi_types.Date `json:"last_month,omitempty"`
	Name      string              `json:"name"`
}

// BudgetSummaryResponse defines model for BudgetSummaryResponse.
type BudgetSummaryResponse struct {
	Data struct {
		Budgets       []BudgetSummary `json:"budgets"`
		DefaultBudget *BudgetSummary  `json:"default_budget,omitempty"`
	} `json:"data"`
}

// CategoriesResponse defines model for CategoriesResponse.
type CategoriesResponse struct {
	Data struct {
		CategoryGroups []CategoryGroupWithCategories `json:"category_groups"`

		// ServerKnowledge The knowledge of the server
		ServerKnowledge int64 `json:"server_knowledge"`
	} `json:"data"`
}

// Category defines model for Category.
type Category struct {
	// Activity Activity amount in milliunits format
	Activity int64 `json:"activity"`

	// Balance Balance in milliunits format
	Balance int64 `json:"balance"`

	// Budgeted Budgeted amount in milliunits format
	Budgeted          int64              `json:"budgeted"`
	CategoryGroupId   openapi_types.UUID `json:"category_group_id"`
	CategoryGroupName *string            `json:"category_group_name,omitempty"`

	// Deleted Whether or not the category has been deleted.  Deleted categories will only be included in delta requests.
	Deleted bool `json:"deleted"`

	// GoalCadence The goal cadence. Value in range 0-14. There are two subsets of these values which behave differently. For values 0, 1, 2, and 13, the goal's due date repeats every goal_cadence * goal_cadence_frequency, where 0 = None, 1 = Monthly, 2 = Weekly, and 13 = Yearly. For example, goal_cadence 1 with goal_cadence_frequency 2 means the goal is due every other month. For values 3-12 and 14, goal_cadence_frequency is ignored and the goal's due date repeats every goal_cadence, where 3 = Every 2 Months, 4 = Every 3 Months, ..., 12 = Every 11 Months, and 14 = Every 2 Years.
	GoalCadence *int32 `json:"goal_cadence"`

	// GoalCadenceFrequency The goal cadence frequency. When goal_cadence is 0, 1, 2, or 13, a goal's due date repeats every goal_cadence * goal_cadence_frequency. For example, goal_cadence 1 with goal_cadence_frequency 2 means the goal is due every other month.  When goal_cadence is 3-12 or 14, goal_cadence_frequency is ignored.
	GoalCadenceFrequency *int32 `json:"goal_cadence_frequency"`

	// GoalCreationMonth The month a goal was created
	GoalCreationMonth *openapi_types.Date `json:"goal_creation_month"`

	// GoalDay A day offset modifier for the goal's due date. When goal_cadence is 2 (Weekly), this value specifies which day of the week the goal is due (0 = Sunday, 6 = Saturday). Otherwise, this value specifies which day of the month the goal is due (1 = 1st, 31 = 31st, null = Last day of Month).
	GoalDay *int32 `json:"goal_day"`

	// GoalMonthsToBudget The number of months, including the current month, left in the current goal period.
	GoalMonthsToBudget *int32 `json:"goal_months_to_budget"`

	// GoalOverallFunded The total amount funded towards the goal within the current goal period.
	GoalOverallFunded *int64 `json:"goal_overall_funded"`

	// GoalOverallLeft The amount of funding still needed to complete the goal within the current goal period.
	GoalOverallLeft *int64 `json:"goal_overall_left"`

	// GoalPercentageComplete The percentage completion of the goal
	GoalPercentageComplete *int32 `json:"goal_percentage_complete"`

	// GoalTarget The goal target amount in milliunits
	GoalTarget *int64 `json:"goal_target"`

	// GoalTargetMonth The original target month for the goal to be completed.  Only some goal types specify this date.
	GoalTargetMonth *openapi_types.Date `json:"goal_target_month"`

	// GoalType The type of goal, if the category has a goal (TB='Target Category Balance', TBD='Target Category Balance by Date', MF='Monthly Funding', NEED='Plan Your Spending')
	GoalType *CategoryGoalType `json:"goal_type"`

	// GoalUnderFunded The amount of funding still needed in the current month to stay on track towards completing the goal within the current goal period. This amount will generally correspond to the 'Underfunded' amount in the web and mobile clients except when viewing a category with a Needed for Spending Goal in a future month.  The web and mobile clients will ignore any funding from a prior goal period when viewing category with a Needed for Spending Goal in a future month.
	GoalUnderFunded *int64 `json:"goal_under_funded"`

	// Hidden Whether or not the category is hidden
	Hidden bool               `json:"hidden"`
	Id     openapi_types.UUID `json:"id"`
	Name   string             `json:"name"`
	Note   *string            `json:"note"`

	// OriginalCategoryGroupId DEPRECATED: No longer used.  Value will always be null.
	OriginalCategoryGroupId *openapi_types.UUID `json:"original_category_group_id"`
}

// CategoryGoalType The type of goal, if the category has a goal (TB='Target Category Balance', TBD='Target Category Balance by Date', MF='Monthly Funding', NEED='Plan Your Spending')
type CategoryGoalType string

// CategoryGroup defines model for CategoryGroup.
type CategoryGroup struct {
	// Deleted Whether or not the category group has been deleted.  Deleted category groups will only be included in delta requests.
	Deleted bool `json:"deleted"`

	// Hidden Whether or not the category group is hidden
	Hidden bool               `json:"hidden"`
	Id     openapi_types.UUID `json:"id"`
	Name   string             `json:"name"`
}

// CategoryGroupWithCategories defines model for CategoryGroupWithCategories.
type CategoryGroupWithCategories struct {
	// Categories Category group categories.  Amounts (budgeted, activity, balance, etc.) are specific to the current budget month (UTC).
	Categories []Category `json:"categories"`

	// Deleted Whether or not the category group has been deleted.  Deleted category groups will only be included in delta requests.
	Deleted bool `json:"deleted"`

	// Hidden Whether or not the category group is hidden
	Hidden bool               `json:"hidden"`
	Id     openapi_types.UUID `json:"id"`
	Name   string             `json:"name"`
}

// CategoryResponse defines model for CategoryResponse.
type CategoryResponse struct {
	Data struct {
		Category Category `json:"category"`
	} `json:"data"`
}

// CurrencyFormat The currency format setting for the budget.  In some cases the format will not be available and will be specified as null.
type CurrencyFormat struct {
	CurrencySymbol   string `json:"currency_symbol"`
	DecimalDigits    int32  `json:"decimal_digits"`
	DecimalSeparator string `json:"decimal_separator"`
	DisplaySymbol    bool   `json:"display_symbol"`
	ExampleFormat    string `json:"example_format"`
	GroupSeparator   string `json:"group_separator"`
	IsoCode          string `json:"iso_code"`
	SymbolFirst      bool   `json:"symbol_first"`
}

// DateFormat The date format setting for the budget.  In some cases the format will not be available and will be specified as null.
type DateFormat struct {
	Format string `json:"format"`
}

// ErrorDetail defines model for ErrorDetail.
type ErrorDetail struct {
	Detail string `json:"detail"`
	Id     string `json:"id"`
	Name   string `json:"name"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	Error ErrorDetail `json:"error"`
}

// HybridTransaction defines model for HybridTransaction.
type HybridTransaction struct {
	AccountId   openapi_types.UUID `json:"account_id"`
	AccountName string             `json:"account_name"`

	// Amount The transaction amount in milliunits format
	Amount int64 `json:"amount"`

	// Approved Whether or not the transaction is approved
	Approved   bool                `json:"approved"`
	CategoryId *openapi_types.UUID `json:"category_id"`

	// CategoryName The name of the category.  If a split transaction, this will be 'Split'.
	CategoryName *string `json:"category_name,omitempty"`

	// Cleared The cleared status of the transaction
	Cleared TransactionClearedStatus `json:"cleared"`

	// Date The transaction date in ISO format (e.g. 2016-12-01)
	Date openapi_types.Date `json:"date"`

	// DebtTransactionType If the transaction is a debt/loan account transaction, the type of transaction
	DebtTransactionType *HybridTransactionDebtTransactionType `json:"debt_transaction_type"`

	// Deleted Whether or not the transaction has been deleted.  Deleted transactions will only be included in delta requests.
	Deleted bool `json:"deleted"`

	// FlagColor The transaction flag
	FlagColor *TransactionFlagColor `json:"flag_color"`
	Id        string                `json:"id"`

	// ImportId If the transaction was imported, this field is a unique (by account) import identifier.  If this transaction was imported through File Based Import or Direct Import and not through the API, the import_id will have the format: 'YNAB:[milliunit_amount]:[iso_date]:[occurrence]'.  For example, a transaction dated 2015-12-30 in the amount of -$294.23 USD would have an import_id of 'YNAB:-294230:2015-12-30:1'.  If a second transaction on the same account was imported and had the same date and same amount, its import_id would be 'YNAB:-294230:2015-12-30:2'.
	ImportId *string `json:"import_id"`

	// ImportPayeeName If the transaction was imported, the payee name that was used when importing and before applying any payee rename rules
	ImportPayeeName *string `json:"import_payee_name"`

	// ImportPayeeNameOriginal If the transaction was imported, the original payee name as it appeared on the statement
	ImportPayeeNameOriginal *string `json:"import_payee_name_original"`

	// MatchedTransactionId If transaction is matched, the id of the matched transaction
	MatchedTransactionId *string `json:"matched_transaction_id"`
	Memo                 *string `json:"memo"`

	// ParentTransactionId For subtransaction types, this is the id of the parent transaction.  For transaction types, this id will be always be null.
	ParentTransactionId *string             `json:"parent_transaction_id"`
	PayeeId             *openapi_types.UUID `json:"payee_id"`
	PayeeName           *string             `json:"payee_name"`

	// TransferAccountId If a transfer transaction, the account to which it transfers
	TransferAccountId *openapi_types.UUID `json:"transfer_account_id"`

	// TransferTransactionId If a transfer transaction, the id of transaction on the other side of the transfer
	TransferTransactionId *string `json:"transfer_transaction_id"`

	// Type Whether the hybrid transaction represents a regular transaction or a subtransaction
	Type HybridTransactionType `json:"type"`
}

// HybridTransactionDebtTransactionType If the transaction is a debt/loan account transaction, the type of transaction
type HybridTransactionDebtTransactionType string

// HybridTransactionType Whether the hybrid transaction represents a regular transaction or a subtransaction
type HybridTransactionType string

// HybridTransactionsResponse defines model for HybridTransactionsResponse.
type HybridTransactionsResponse struct {
	Data struct {
		// ServerKnowledge The knowledge of the server
		ServerKnowledge *int64              `json:"server_knowledge,omitempty"`
		Transactions    []HybridTransaction `json:"transactions"`
	} `json:"data"`
}

// LoanAccountPeriodicValue defines model for LoanAccountPeriodicValue.
type LoanAccountPeriodicValue map[string]int64

// MonthDetail defines model for MonthDetail.
type MonthDetail struct {
	// Activity The total amount of transactions in the month, excluding those categorized to 'Inflow: Ready to Assign'
	Activity int64 `json:"activity"`

	// AgeOfMoney The Age of Money as of the month
	AgeOfMoney *int32 `json:"age_of_money"`

	// Budgeted The total amount budgeted in the month
	Budgeted int64 `json:"budgeted"`

	// Categories The budget month categories.  Amounts (budgeted, activity, balance, etc.) are specific to the {month} parameter specified.
	Categories []Category `json:"categories"`

	// Deleted Whether or not the month has been deleted.  Deleted months will only be included in delta requests.
	Deleted bool `json:"deleted"`

	// Income The total amount of transactions categorized to 'Inflow: Ready to Assign' in the month
	Income int64              `json:"income"`
	Month  openapi_types.Date `json:"month"`
	Note   *string            `json:"note"`

	// ToBeBudgeted The available amount for 'Ready to Assign'
	ToBeBudgeted int64 `json:"to_be_budgeted"`
}

// MonthDetailResponse defines model for MonthDetailResponse.
type MonthDetailResponse struct {
	Data struct {
		Month MonthDetail `json:"month"`
	} `json:"data"`
}

// MonthSummariesResponse defines model for MonthSummariesResponse.
type MonthSummariesResponse struct {
	Data struct {
		Months []MonthSummary `json:"months"`

		// ServerKnowledge The knowledge of the server
		ServerKnowledge int64 `json:"server_knowledge"`
	} `json:"data"`
}

// MonthSummary defines model for MonthSummary.
type MonthSummary struct {
	// Activity The total amount of transactions in the month, excluding those categorized to 'Inflow: Ready to Assign'
	Activity int64 `json:"activity"`

	// AgeOfMoney The Age of Money as of the month
	AgeOfMoney *int32 `json:"age_of_money"`

	// Budgeted The total amount budgeted in the month
	Budgeted int64 `json:"budgeted"`

	// Deleted Whether or not the month has been deleted.  Deleted months will only be included in delta requests.
	Deleted bool `json:"deleted"`

	// Income The total amount of transactions categorized to 'Inflow: Ready to Assign' in the month
	Income int64              `json:"income"`
	Month  openapi_types.Date `json:"month"`
	Note   *string            `json:"note"`

	// ToBeBudgeted The available amount for 'Ready to Assign'
	ToBeBudgeted int64 `json:"to_be_budgeted"`
}

// PatchCategoryWrapper defines model for PatchCategoryWrapper.
type PatchCategoryWrapper struct {
	Category SaveCategory `json:"category"`
}

// PatchMonthCategoryWrapper defines model for PatchMonthCategoryWrapper.
type PatchMonthCategoryWrapper struct {
	Category SaveMonthCategory `json:"category"`
}

// PatchTransactionsWrapper defines model for PatchTransactionsWrapper.
type PatchTransactionsWrapper struct {
	Transactions []SaveTransactionWithId `json:"transactions"`
}

// Payee defines model for Payee.
type Payee struct {
	// Deleted Whether or not the payee has been deleted.  Deleted payees will only be included in delta requests.
	Deleted bool               `json:"deleted"`
	Id      openapi_types.UUID `json:"id"`
	Name    string             `json:"name"`

	// TransferAccountId If a transfer payee, the `account_id` to which this payee transfers to
	TransferAccountId *string `json:"transfer_account_id"`
}

// PayeeLocation defines model for PayeeLocation.
type PayeeLocation struct {
	// Deleted Whether or not the payee location has been deleted.  Deleted payee locations will only be included in delta requests.
	Deleted   bool               `json:"deleted"`
	Id        openapi_types.UUID `json:"id"`
	Latitude  string             `json:"latitude"`
	Longitude string             `json:"longitude"`
	PayeeId   openapi_types.UUID `json:"payee_id"`
}

// PayeeLocationResponse defines model for PayeeLocationResponse.
type PayeeLocationResponse struct {
	Data struct {
		PayeeLocation PayeeLocation `json:"payee_location"`
	} `json:"data"`
}

// PayeeLocationsResponse defines model for PayeeLocationsResponse.
type PayeeLocationsResponse struct {
	Data struct {
		PayeeLocations []PayeeLocation `json:"payee_locations"`
	} `json:"data"`
}

// PayeeResponse defines model for PayeeResponse.
type PayeeResponse struct {
	Data struct {
		Payee Payee `json:"payee"`
	} `json:"data"`
}

// PayeesResponse defines model for PayeesResponse.
type PayeesResponse struct {
	Data struct {
		Payees []Payee `json:"payees"`

		// ServerKnowledge The knowledge of the server
		ServerKnowledge int64 `json:"server_knowledge"`
	} `json:"data"`
}

// PostAccountWrapper defines model for PostAccountWrapper.
type PostAccountWrapper struct {
	Account SaveAccount `json:"account"`
}

// PostTransactionsWrapper defines model for PostTransactionsWrapper.
type PostTransactionsWrapper struct {
	Transaction  *SaveTransaction   `json:"transaction,omitempty"`
	Transactions *[]SaveTransaction `json:"transactions,omitempty"`
}

// PutTransactionWrapper defines model for PutTransactionWrapper.
type PutTransactionWrapper struct {
	Transaction SaveTransaction `json:"transaction"`
}

// SaveAccount defines model for SaveAccount.
type SaveAccount struct {
	// Balance The current balance of the account in milliunits format
	Balance int64 `json:"balance"`

	// Name The name of the account
	Name string `json:"name"`

	// Type The type of account
	Type AccountType `json:"type"`
}

// SaveCategory defines model for SaveCategory.
type SaveCategory struct {
	CategoryGroupId *openapi_types.UUID `json:"category_group_id,omitempty"`
	Name            *string             `json:"name"`
	Note            *string             `json:"note"`
}

// SaveCategoryResponse defines model for SaveCategoryResponse.
type SaveCategoryResponse struct {
	Data struct {
		Category Category `json:"category"`

		// ServerKnowledge The knowledge of the server
		ServerKnowledge int64 `json:"server_knowledge"`
	} `json:"data"`
}

// SaveMonthCategory defines model for SaveMonthCategory.
type SaveMonthCategory struct {
	// Budgeted Budgeted amount in milliunits format
	Budgeted int64 `json:"budgeted"`
}

// SaveSubTransaction defines model for SaveSubTransaction.
type SaveSubTransaction struct {
	// Amount The subtransaction amount in milliunits format.
	Amount int64 `json:"amount"`

	// CategoryId The category for the subtransaction.  Credit Card Payment categories are not permitted and will be ignored if supplied.
	CategoryId *openapi_types.UUID `json:"category_id"`
	Memo       *string             `json:"memo"`

	// PayeeId The payee for the subtransaction.
	PayeeId *openapi_types.UUID `json:"payee_id"`

	// PayeeName The payee name.  If a `payee_name` value is provided and `payee_id` has a null value, the `payee_name` value will be used to resolve the payee by either (1) a matching payee rename rule (only if import_id is also specified on parent transaction) or (2) a payee with the same name or (3) creation of a new payee.
	PayeeName *string `json:"payee_name"`
}

// SaveTransaction defines model for SaveTransaction.
type SaveTransaction struct {
	AccountId *openapi_types.UUID `json:"account_id,omitempty"`

	// Amount The transaction amount in milliunits format.  Split transaction amounts cannot be changed and if a different amount is supplied it will be ignored.
	Amount *int64 `json:"amount,omitempty"`

	// Approved Whether or not the transaction is approved.  If not supplied, transaction will be unapproved by default.
	Approved *bool `json:"approved,omitempty"`

	// CategoryId The category for the transaction.  To configure a split transaction, you can specify null for `category_id` and provide a `subtransactions` array as part of the transaction object.  If an existing transaction is a split, the `category_id` cannot be changed.  Credit Card Payment categories are not permitted and will be ignored if supplied.
	CategoryId *openapi_types.UUID `json:"category_id"`

	// Cleared The cleared status of the transaction
	Cleared *TransactionClearedStatus `json:"cleared,omitempty"`

	// Date The transaction date in ISO format (e.g. 2016-12-01).  Future dates (scheduled transactions) are not permitted.  Split transaction dates cannot be changed and if a different date is supplied it will be ignored.
	Date *openapi_types.Date `json:"date,omitempty"`

	// FlagColor The transaction flag
	FlagColor *TransactionFlagColor `json:"flag_color"`

	// ImportId If specified, the new transaction will be assigned this `import_id` and considered "imported".  We will also attempt to match this imported transaction to an existing "user-entered" transation on the same account, with the same amount, and with a date +/-10 days from the imported transaction date.<br><br>Transactions imported through File Based Import or Direct Import (not through the API) are assigned an import_id in the format: 'YNAB:[milliunit_amount]:[iso_date]:[occurrence]'. For example, a transaction dated 2015-12-30 in the amount of -$294.23 USD would have an import_id of 'YNAB:-294230:2015-12-30:1'.  If a second transaction on the same account was imported and had the same date and same amount, its import_id would be 'YNAB:-294230:2015-12-30:2'.  Using a consistent format will prevent duplicates through Direct Import and File Based Import.<br><br>If import_id is omitted or specified as null, the transaction will be treated as a "user-entered" transaction. As such, it will be eligible to be matched against transactions later being imported (via DI, FBI, or API).
	ImportId *string `json:"import_id"`
	Memo     *string `json:"memo"`

	// PayeeId The payee for the transaction.  To create a transfer between two accounts, use the account transfer payee pointing to the target account.  Account transfer payees are specified as `tranfer_payee_id` on the account resource.
	PayeeId *openapi_types.UUID `json:"payee_id"`

	// PayeeName The payee name.  If a `payee_name` value is provided and `payee_id` has a null value, the `payee_name` value will be used to resolve the payee by either (1) a matching payee rename rule (only if `import_id` is also specified) or (2) a payee with the same name or (3) creation of a new payee.
	PayeeName *string `json:"payee_name"`

	// Subtransactions An array of subtransactions to configure a transaction as a split. Updating `subtransactions` on an existing split transaction is not supported.
	Subtransactions *[]SaveSubTransaction `json:"subtransactions,omitempty"`
}

// SaveTransactionWithId defines model for SaveTransactionWithId.
type SaveTransactionWithId struct {
	AccountId *openapi_types.UUID `json:"account_id,omitempty"`

	// Amount The transaction amount in milliunits format.  Split transaction amounts cannot be changed and if a different amount is supplied it will be ignored.
	Amount *int64 `json:"amount,omitempty"`

	// Approved Whether or not the transaction is approved.  If not supplied, transaction will be unapproved by default.
	Approved *bool `json:"approved,omitempty"`

	// CategoryId The category for the transaction.  To configure a split transaction, you can specify null for `category_id` and provide a `subtransactions` array as part of the transaction object.  If an existing transaction is a split, the `category_id` cannot be changed.  Credit Card Payment categories are not permitted and will be ignored if supplied.
	CategoryId *openapi_types.UUID `json:"category_id"`

	// Cleared The cleared status of the transaction
	Cleared *TransactionClearedStatus `json:"cleared,omitempty"`

	// Date The transaction date in ISO format (e.g. 2016-12-01).  Future dates (scheduled transactions) are not permitted.  Split transaction dates cannot be changed and if a different date is supplied it will be ignored.
	Date *openapi_types.Date `json:"date,omitempty"`

	// FlagColor The transaction flag
	FlagColor *TransactionFlagColor `json:"flag_color"`
	Id        *string               `json:"id,omitempty"`

	// ImportId If specified, the new transaction will be assigned this `import_id` and considered "imported".  We will also attempt to match this imported transaction to an existing "user-entered" transation on the same account, with the same amount, and with a date +/-10 days from the imported transaction date.<br><br>Transactions imported through File Based Import or Direct Import (not through the API) are assigned an import_id in the format: 'YNAB:[milliunit_amount]:[iso_date]:[occurrence]'. For example, a transaction dated 2015-12-30 in the amount of -$294.23 USD would have an import_id of 'YNAB:-294230:2015-12-30:1'.  If a second transaction on the same account was imported and had the same date and same amount, its import_id would be 'YNAB:-294230:2015-12-30:2'.  Using a consistent format will prevent duplicates through Direct Import and File Based Import.<br><br>If import_id is omitted or specified as null, the transaction will be treated as a "user-entered" transaction. As such, it will be eligible to be matched against transactions later being imported (via DI, FBI, or API).
	ImportId *string `json:"import_id"`
	Memo     *string `json:"memo"`

	// PayeeId The payee for the transaction.  To create a transfer between two accounts, use the account transfer payee pointing to the target account.  Account transfer payees are specified as `tranfer_payee_id` on the account resource.
	PayeeId *openapi_types.UUID `json:"payee_id"`

	// PayeeName The payee name.  If a `payee_name` value is provided and `payee_id` has a null value, the `payee_name` value will be used to resolve the payee by either (1) a matching payee rename rule (only if `import_id` is also specified) or (2) a payee with the same name or (3) creation of a new payee.
	PayeeName *string `json:"payee_name"`

	// Subtransactions An array of subtransactions to configure a transaction as a split. Updating `subtransactions` on an existing split transaction is not supported.
	Subtransactions *[]SaveSubTransaction `json:"subtransactions,omitempty"`
}

// SaveTransactionWithOptionalFields defines model for SaveTransactionWithOptionalFields.
type SaveTransactionWithOptionalFields struct {
	AccountId *openapi_types.UUID `json:"account_id,omitempty"`

	// Amount The transaction amount in milliunits format.  Split transaction amounts cannot be changed and if a different amount is supplied it will be ignored.
	Amount *int64 `json:"amount,omitempty"`

	// Approved Whether or not the transaction is approved.  If not supplied, transaction will be unapproved by default.
	Approved *bool `json:"approved,omitempty"`

	// CategoryId The category for the transaction.  To configure a split transaction, you can specify null for `category_id` and provide a `subtransactions` array as part of the transaction object.  If an existing transaction is a split, the `category_id` cannot be changed.  Credit Card Payment categories are not permitted and will be ignored if supplied.
	CategoryId *openapi_types.UUID `json:"category_id"`

	// Cleared The cleared status of the transaction
	Cleared *TransactionClearedStatus `json:"cleared,omitempty"`

	// Date The transaction date in ISO format (e.g. 2016-12-01).  Future dates (scheduled transactions) are not permitted.  Split transaction dates cannot be changed and if a different date is supplied it will be ignored.
	Date *openapi_types.Date `json:"date,omitempty"`

	// FlagColor The transaction flag
	FlagColor *TransactionFlagColor `json:"flag_color"`

	// ImportId If specified, the new transaction will be assigned this `import_id` and considered "imported".  We will also attempt to match this imported transaction to an existing "user-entered" transation on the same account, with the same amount, and with a date +/-10 days from the imported transaction date.<br><br>Transactions imported through File Based Import or Direct Import (not through the API) are assigned an import_id in the format: 'YNAB:[milliunit_amount]:[iso_date]:[occurrence]'. For example, a transaction dated 2015-12-30 in the amount of -$294.23 USD would have an import_id of 'YNAB:-294230:2015-12-30:1'.  If a second transaction on the same account was imported and had the same date and same amount, its import_id would be 'YNAB:-294230:2015-12-30:2'.  Using a consistent format will prevent duplicates through Direct Import and File Based Import.<br><br>If import_id is omitted or specified as null, the transaction will be treated as a "user-entered" transaction. As such, it will be eligible to be matched against transactions later being imported (via DI, FBI, or API).
	ImportId *string `json:"import_id"`
	Memo     *string `json:"memo"`

	// PayeeId The payee for the transaction.  To create a transfer between two accounts, use the account transfer payee pointing to the target account.  Account transfer payees are specified as `tranfer_payee_id` on the account resource.
	PayeeId *openapi_types.UUID `json:"payee_id"`

	// PayeeName The payee name.  If a `payee_name` value is provided and `payee_id` has a null value, the `payee_name` value will be used to resolve the payee by either (1) a matching payee rename rule (only if `import_id` is also specified) or (2) a payee with the same name or (3) creation of a new payee.
	PayeeName *string `json:"payee_name"`

	// Subtransactions An array of subtransactions to configure a transaction as a split. Updating `subtransactions` on an existing split transaction is not supported.
	Subtransactions *[]SaveSubTransaction `json:"subtransactions,omitempty"`
}

// SaveTransactionsResponse defines model for SaveTransactionsResponse.
type SaveTransactionsResponse struct {
	Data struct {
		// DuplicateImportIds If multiple transactions were specified, a list of import_ids that were not created because of an existing `import_id` found on the same account
		DuplicateImportIds *[]string `json:"duplicate_import_ids,omitempty"`

		// ServerKnowledge The knowledge of the server
		ServerKnowledge int64              `json:"server_knowledge"`
		Transaction     *TransactionDetail `json:"transaction,omitempty"`

		// TransactionIds The transaction ids that were saved
		TransactionIds []string `json:"transaction_ids"`

		// Transactions If multiple transactions were specified, the transactions that were saved
		Transactions *[]TransactionDetail `json:"transactions,omitempty"`
	} `json:"data"`
}

// ScheduledSubTransaction defines model for ScheduledSubTransaction.
type ScheduledSubTransaction struct {
	// Amount The scheduled subtransaction amount in milliunits format
	Amount     int64               `json:"amount"`
	CategoryId *openapi_types.UUID `json:"category_id"`

	// Deleted Whether or not the scheduled subtransaction has been deleted. Deleted scheduled subtransactions will only be included in delta requests.
	Deleted                bool                `json:"deleted"`
	Id                     openapi_types.UUID  `json:"id"`
	Memo                   *string             `json:"memo"`
	PayeeId                *openapi_types.UUID `json:"payee_id"`
	ScheduledTransactionId openapi_types.UUID  `json:"scheduled_transaction_id"`

	// TransferAccountId If a transfer, the account_id which the scheduled subtransaction transfers to
	TransferAccountId *openapi_types.UUID `json:"transfer_account_id"`
}

// ScheduledTransactionDetail defines model for ScheduledTransactionDetail.
type ScheduledTransactionDetail struct {
	AccountId   openapi_types.UUID `json:"account_id"`
	AccountName string             `json:"account_name"`

	// Amount The scheduled transaction amount in milliunits format
	Amount     int64               `json:"amount"`
	CategoryId *openapi_types.UUID `json:"category_id"`

	// CategoryName The name of the category.  If a split scheduled transaction, this will be 'Split'.
	CategoryName *string `json:"category_name"`

	// DateFirst The first date for which the Scheduled Transaction was scheduled.
	DateFirst openapi_types.Date `json:"date_first"`

	// DateNext The next date for which the Scheduled Transaction is scheduled.
	DateNext openapi_types.Date `json:"date_next"`

	// Deleted Whether or not the scheduled transaction has been deleted.  Deleted scheduled transactions will only be included in delta requests.
	Deleted bool `json:"deleted"`

	// FlagColor The transaction flag
	FlagColor *TransactionFlagColor               `json:"flag_color"`
	Frequency ScheduledTransactionDetailFrequency `json:"frequency"`
	Id        openapi_types.UUID                  `json:"id"`
	Memo      *string                             `json:"memo"`
	PayeeId   *openapi_types.UUID                 `json:"payee_id"`
	PayeeName *string                             `json:"payee_name"`

	// Subtransactions If a split scheduled transaction, the subtransactions.
	Subtransactions []ScheduledSubTransaction `json:"subtransactions"`

	// TransferAccountId If a transfer, the account_id which the scheduled transaction transfers to
	TransferAccountId *openapi_types.UUID `json:"transfer_account_id"`
}

// ScheduledTransactionDetailFrequency defines model for ScheduledTransactionDetail.Frequency.
type ScheduledTransactionDetailFrequency string

// ScheduledTransactionResponse defines model for ScheduledTransactionResponse.
type ScheduledTransactionResponse struct {
	Data struct {
		ScheduledTransaction ScheduledTransactionDetail `json:"scheduled_transaction"`
	} `json:"data"`
}

// ScheduledTransactionSummary defines model for ScheduledTransactionSummary.
type ScheduledTransactionSummary struct {
	AccountId openapi_types.UUID `json:"account_id"`

	// Amount The scheduled transaction amount in milliunits format
	Amount     int64               `json:"amount"`
	CategoryId *openapi_types.UUID `json:"category_id"`

	// DateFirst The first date for which the Scheduled Transaction was scheduled.
	DateFirst openapi_types.Date `json:"date_first"`

	// DateNext The next date for which the Scheduled Transaction is scheduled.
	DateNext openapi_types.Date `json:"date_next"`

	// Deleted Whether or not the scheduled transaction has been deleted.  Deleted scheduled transactions will only be included in delta requests.
	Deleted bool `json:"deleted"`

	// FlagColor The transaction flag
	FlagColor *TransactionFlagColor                `json:"flag_color"`
	Frequency ScheduledTransactionSummaryFrequency `json:"frequency"`
	Id        openapi_types.UUID                   `json:"id"`
	Memo      *string                              `json:"memo"`
	PayeeId   *openapi_types.UUID                  `json:"payee_id"`

	// TransferAccountId If a transfer, the account_id which the scheduled transaction transfers to
	TransferAccountId *openapi_types.UUID `json:"transfer_account_id"`
}

// ScheduledTransactionSummaryFrequency defines model for ScheduledTransactionSummary.Frequency.
type ScheduledTransactionSummaryFrequency string

// ScheduledTransactionsResponse defines model for ScheduledTransactionsResponse.
type ScheduledTransactionsResponse struct {
	Data struct {
		ScheduledTransactions []ScheduledTransactionDetail `json:"scheduled_transactions"`

		// ServerKnowledge The knowledge of the server
		ServerKnowledge int64 `json:"server_knowledge"`
	} `json:"data"`
}

// SubTransaction defines model for SubTransaction.
type SubTransaction struct {
	// Amount The subtransaction amount in milliunits format
	Amount       int64               `json:"amount"`
	CategoryId   *openapi_types.UUID `json:"category_id"`
	CategoryName *string             `json:"category_name"`

	// Deleted Whether or not the subtransaction has been deleted.  Deleted subtransactions will only be included in delta requests.
	Deleted       bool                `json:"deleted"`
	Id            string              `json:"id"`
	Memo          *string             `json:"memo"`
	PayeeId       *openapi_types.UUID `json:"payee_id"`
	PayeeName     *string             `json:"payee_name"`
	TransactionId string              `json:"transaction_id"`

	// TransferAccountId If a transfer, the account_id which the subtransaction transfers to
	TransferAccountId *openapi_types.UUID `json:"transfer_account_id"`

	// TransferTransactionId If a transfer, the id of transaction on the other side of the transfer
	TransferTransactionId *string `json:"transfer_transaction_id"`
}

// TransactionClearedStatus The cleared status of the transaction
type TransactionClearedStatus string

// TransactionDetail defines model for TransactionDetail.
type TransactionDetail struct {
	AccountId   openapi_types.UUID `json:"account_id"`
	AccountName string             `json:"account_name"`

	// Amount The transaction amount in milliunits format
	Amount int64 `json:"amount"`

	// Approved Whether or not the transaction is approved
	Approved   bool                `json:"approved"`
	CategoryId *openapi_types.UUID `json:"category_id"`

	// CategoryName The name of the category.  If a split transaction, this will be 'Split'.
	CategoryName *string `json:"category_name"`

	// Cleared The cleared status of the transaction
	Cleared TransactionClearedStatus `json:"cleared"`

	// Date The transaction date in ISO format (e.g. 2016-12-01)
	Date openapi_types.Date `json:"date"`

	// DebtTransactionType If the transaction is a debt/loan account transaction, the type of transaction
	DebtTransactionType *TransactionDetailDebtTransactionType `json:"debt_transaction_type"`

	// Deleted Whether or not the transaction has been deleted.  Deleted transactions will only be included in delta requests.
	Deleted bool `json:"deleted"`

	// FlagColor The transaction flag
	FlagColor *TransactionFlagColor `json:"flag_color"`
	Id        string                `json:"id"`

	// ImportId If the transaction was imported, this field is a unique (by account) import identifier.  If this transaction was imported through File Based Import or Direct Import and not through the API, the import_id will have the format: 'YNAB:[milliunit_amount]:[iso_date]:[occurrence]'.  For example, a transaction dated 2015-12-30 in the amount of -$294.23 USD would have an import_id of 'YNAB:-294230:2015-12-30:1'.  If a second transaction on the same account was imported and had the same date and same amount, its import_id would be 'YNAB:-294230:2015-12-30:2'.
	ImportId *string `json:"import_id"`

	// ImportPayeeName If the transaction was imported, the payee name that was used when importing and before applying any payee rename rules
	ImportPayeeName *string `json:"import_payee_name"`

	// ImportPayeeNameOriginal If the transaction was imported, the original payee name as it appeared on the statement
	ImportPayeeNameOriginal *string `json:"import_payee_name_original"`

	// MatchedTransactionId If transaction is matched, the id of the matched transaction
	MatchedTransactionId *string             `json:"matched_transaction_id"`
	Memo                 *string             `json:"memo"`
	PayeeId              *openapi_types.UUID `json:"payee_id"`
	PayeeName            *string             `json:"payee_name"`

	// Subtransactions If a split transaction, the subtransactions.
	Subtransactions []SubTransaction `json:"subtransactions"`

	// TransferAccountId If a transfer transaction, the account to which it transfers
	TransferAccountId *openapi_types.UUID `json:"transfer_account_id"`

	// TransferTransactionId If a transfer transaction, the id of transaction on the other side of the transfer
	TransferTransactionId *string `json:"transfer_transaction_id"`
}

// TransactionDetailDebtTransactionType If the transaction is a debt/loan account transaction, the type of transaction
type TransactionDetailDebtTransactionType string

// TransactionFlagColor The transaction flag
type TransactionFlagColor string

// TransactionResponse defines model for TransactionResponse.
type TransactionResponse struct {
	Data struct {
		Transaction TransactionDetail `json:"transaction"`
	} `json:"data"`
}

// TransactionSummary defines model for TransactionSummary.
type TransactionSummary struct {
	AccountId openapi_types.UUID `json:"account_id"`

	// Amount The transaction amount in milliunits format
	Amount int64 `json:"amount"`

	// Approved Whether or not the transaction is approved
	Approved   bool                `json:"approved"`
	CategoryId *openapi_types.UUID `json:"category_id"`

	// Cleared The cleared status of the transaction
	Cleared TransactionClearedStatus `json:"cleared"`

	// Date The transaction date in ISO format (e.g. 2016-12-01)
	Date openapi_types.Date `json:"date"`

	// DebtTransactionType If the transaction is a debt/loan account transaction, the type of transaction
	DebtTransactionType *TransactionSummaryDebtTransactionType `json:"debt_transaction_type"`

	// Deleted Whether or not the transaction has been deleted.  Deleted transactions will only be included in delta requests.
	Deleted bool `json:"deleted"`

	// FlagColor The transaction flag
	FlagColor *TransactionFlagColor `json:"flag_color"`
	Id        string                `json:"id"`

	// ImportId If the transaction was imported, this field is a unique (by account) import identifier.  If this transaction was imported through File Based Import or Direct Import and not through the API, the import_id will have the format: 'YNAB:[milliunit_amount]:[iso_date]:[occurrence]'.  For example, a transaction dated 2015-12-30 in the amount of -$294.23 USD would have an import_id of 'YNAB:-294230:2015-12-30:1'.  If a second transaction on the same account was imported and had the same date and same amount, its import_id would be 'YNAB:-294230:2015-12-30:2'.
	ImportId *string `json:"import_id"`

	// ImportPayeeName If the transaction was imported, the payee name that was used when importing and before applying any payee rename rules
	ImportPayeeName *string `json:"import_payee_name"`

	// ImportPayeeNameOriginal If the transaction was imported, the original payee name as it appeared on the statement
	ImportPayeeNameOriginal *string `json:"import_payee_name_original"`

	// MatchedTransactionId If transaction is matched, the id of the matched transaction
	MatchedTransactionId *string             `json:"matched_transaction_id"`
	Memo                 *string             `json:"memo"`
	PayeeId              *openapi_types.UUID `json:"payee_id"`

	// TransferAccountId If a transfer transaction, the account to which it transfers
	TransferAccountId *openapi_types.UUID `json:"transfer_account_id"`

	// TransferTransactionId If a transfer transaction, the id of transaction on the other side of the transfer
	TransferTransactionId *string `json:"transfer_transaction_id"`
}

// TransactionSummaryDebtTransactionType If the transaction is a debt/loan account transaction, the type of transaction
type TransactionSummaryDebtTransactionType string

// TransactionsImportResponse defines model for TransactionsImportResponse.
type TransactionsImportResponse struct {
	Data struct {
		// TransactionIds The list of transaction ids that were imported.
		TransactionIds []string `json:"transaction_ids"`
	} `json:"data"`
}

// TransactionsResponse defines model for TransactionsResponse.
type TransactionsResponse struct {
	Data struct {
		// ServerKnowledge The knowledge of the server
		ServerKnowledge int64               `json:"server_knowledge"`
		Transactions    []TransactionDetail `json:"transactions"`
	} `json:"data"`
}

// User defines model for User.
type User struct {
	Id openapi_types.UUID `json:"id"`
}

// UserResponse defines model for UserResponse.
type UserResponse struct {
	Data struct {
		User User `json:"user"`
	} `json:"data"`
}

// GetBudgetsParams defines parameters for GetBudgets.
type GetBudgetsParams struct {
	// IncludeAccounts Whether to include the list of budget accounts
	IncludeAccounts *bool `form:"include_accounts,omitempty" json:"include_accounts,omitempty"`
}

// GetBudgetByIdParams defines parameters for GetBudgetById.
type GetBudgetByIdParams struct {
	// LastKnowledgeOfServer The starting server knowledge.  If provided, only entities that have changed since `last_knowledge_of_server` will be included.
	LastKnowledgeOfServer *int64 `form:"last_knowledge_of_server,omitempty" json:"last_knowledge_of_server,omitempty"`
}

// GetAccountsParams defines parameters for GetAccounts.
type GetAccountsParams struct {
	// LastKnowledgeOfServer The starting server knowledge.  If provided, only entities that have changed since `last_knowledge_of_server` will be included.
	LastKnowledgeOfServer *int64 `form:"last_knowledge_of_server,omitempty" json:"last_knowledge_of_server,omitempty"`
}

// GetTransactionsByAccountParams defines parameters for GetTransactionsByAccount.
type GetTransactionsByAccountParams struct {
	// SinceDate If specified, only transactions on or after this date will be included.  The date should be ISO formatted (e.g. 2016-12-30).
	SinceDate *openapi_types.Date `form:"since_date,omitempty" json:"since_date,omitempty"`

	// Type If specified, only transactions of the specified type will be included. "uncategorized" and "unapproved" are currently supported.
	Type *GetTransactionsByAccountParamsType `form:"type,omitempty" json:"type,omitempty"`

	// LastKnowledgeOfServer The starting server knowledge.  If provided, only entities that have changed since `last_knowledge_of_server` will be included.
	LastKnowledgeOfServer *int64 `form:"last_knowledge_of_server,omitempty" json:"last_knowledge_of_server,omitempty"`
}

// GetTransactionsByAccountParamsType defines parameters for GetTransactionsByAccount.
type GetTransactionsByAccountParamsType string

// GetCategoriesParams defines parameters for GetCategories.
type GetCategoriesParams struct {
	// LastKnowledgeOfServer The starting server knowledge.  If provided, only entities that have changed since `last_knowledge_of_server` will be included.
	LastKnowledgeOfServer *int64 `form:"last_knowledge_of_server,omitempty" json:"last_knowledge_of_server,omitempty"`
}

// GetTransactionsByCategoryParams defines parameters for GetTransactionsByCategory.
type GetTransactionsByCategoryParams struct {
	// SinceDate If specified, only transactions on or after this date will be included.  The date should be ISO formatted (e.g. 2016-12-30).
	SinceDate *openapi_types.Date `form:"since_date,omitempty" json:"since_date,omitempty"`

	// Type If specified, only transactions of the specified type will be included. "uncategorized" and "unapproved" are currently supported.
	Type *GetTransactionsByCategoryParamsType `form:"type,omitempty" json:"type,omitempty"`

	// LastKnowledgeOfServer The starting server knowledge.  If provided, only entities that have changed since `last_knowledge_of_server` will be included.
	LastKnowledgeOfServer *int64 `form:"last_knowledge_of_server,omitempty" json:"last_knowledge_of_server,omitempty"`
}

// GetTransactionsByCategoryParamsType defines parameters for GetTransactionsByCategory.
type GetTransactionsByCategoryParamsType string

// GetBudgetMonthsParams defines parameters for GetBudgetMonths.
type GetBudgetMonthsParams struct {
	// LastKnowledgeOfServer The starting server knowledge.  If provided, only entities that have changed since `last_knowledge_of_server` will be included.
	LastKnowledgeOfServer *int64 `form:"last_knowledge_of_server,omitempty" json:"last_knowledge_of_server,omitempty"`
}

// GetPayeesParams defines parameters for GetPayees.
type GetPayeesParams struct {
	// LastKnowledgeOfServer The starting server knowledge.  If provided, only entities that have changed since `last_knowledge_of_server` will be included.
	LastKnowledgeOfServer *int64 `form:"last_knowledge_of_server,omitempty" json:"last_knowledge_of_server,omitempty"`
}

// GetTransactionsByPayeeParams defines parameters for GetTransactionsByPayee.
type GetTransactionsByPayeeParams struct {
	// SinceDate If specified, only transactions on or after this date will be included.  The date should be ISO formatted (e.g. 2016-12-30).
	SinceDate *openapi_types.Date `form:"since_date,omitempty" json:"since_date,omitempty"`

	// Type If specified, only transactions of the specified type will be included. "uncategorized" and "unapproved" are currently supported.
	Type *GetTransactionsByPayeeParamsType `form:"type,omitempty" json:"type,omitempty"`

	// LastKnowledgeOfServer The starting server knowledge.  If provided, only entities that have changed since `last_knowledge_of_server` will be included.
	LastKnowledgeOfServer *int64 `form:"last_knowledge_of_server,omitempty" json:"last_knowledge_of_server,omitempty"`
}

// GetTransactionsByPayeeParamsType defines parameters for GetTransactionsByPayee.
type GetTransactionsByPayeeParamsType string

// GetScheduledTransactionsParams defines parameters for GetScheduledTransactions.
type GetScheduledTransactionsParams struct {
	// LastKnowledgeOfServer The starting server knowledge.  If provided, only entities that have changed since `last_knowledge_of_server` will be included.
	LastKnowledgeOfServer *int64 `form:"last_knowledge_of_server,omitempty" json:"last_knowledge_of_server,omitempty"`
}

// GetTransactionsParams defines parameters for GetTransactions.
type GetTransactionsParams struct {
	// SinceDate If specified, only transactions on or after this date will be included.  The date should be ISO formatted (e.g. 2016-12-30).
	SinceDate *openapi_types.Date `form:"since_date,omitempty" json:"since_date,omitempty"`

	// Type If specified, only transactions of the specified type will be included. "uncategorized" and "unapproved" are currently supported.
	Type *GetTransactionsParamsType `form:"type,omitempty" json:"type,omitempty"`

	// LastKnowledgeOfServer The starting server knowledge.  If provided, only entities that have changed since `last_knowledge_of_server` will be included.
	LastKnowledgeOfServer *int64 `form:"last_knowledge_of_server,omitempty" json:"last_knowledge_of_server,omitempty"`
}

// GetTransactionsParamsType defines parameters for GetTransactions.
type GetTransactionsParamsType string

// CreateAccountJSONRequestBody defines body for CreateAccount for application/json ContentType.
type CreateAccountJSONRequestBody = PostAccountWrapper

// UpdateCategoryJSONRequestBody defines body for UpdateCategory for application/json ContentType.
type UpdateCategoryJSONRequestBody = PatchCategoryWrapper

// UpdateMonthCategoryJSONRequestBody defines body for UpdateMonthCategory for application/json ContentType.
type UpdateMonthCategoryJSONRequestBody = PatchMonthCategoryWrapper

// UpdateTransactionsJSONRequestBody defines body for UpdateTransactions for application/json ContentType.
type UpdateTransactionsJSONRequestBody = PatchTransactionsWrapper

// CreateTransactionJSONRequestBody defines body for CreateTransaction for application/json ContentType.
type CreateTransactionJSONRequestBody = PostTransactionsWrapper

// UpdateTransactionJSONRequestBody defines body for UpdateTransaction for application/json ContentType.
type UpdateTransactionJSONRequestBody = PutTransactionWrapper

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetBudgets request
	GetBudgets(ctx context.Context, params *GetBudgetsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBudgetById request
	GetBudgetById(ctx context.Context, budgetId string, params *GetBudgetByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAccounts request
	GetAccounts(ctx context.Context, budgetId string, params *GetAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAccountWithBody request with any body
	CreateAccountWithBody(ctx context.Context, budgetId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAccount(ctx context.Context, budgetId string, body CreateAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAccountById request
	GetAccountById(ctx context.Context, budgetId string, accountId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTransactionsByAccount request
	GetTransactionsByAccount(ctx context.Context, budgetId string, accountId string, params *GetTransactionsByAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCategories request
	GetCategories(ctx context.Context, budgetId string, params *GetCategoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCategoryById request
	GetCategoryById(ctx context.Context, budgetId string, categoryId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateCategoryWithBody request with any body
	UpdateCategoryWithBody(ctx context.Context, budgetId string, categoryId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateCategory(ctx context.Context, budgetId string, categoryId string, body UpdateCategoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTransactionsByCategory request
	GetTransactionsByCategory(ctx context.Context, budgetId string, categoryId string, params *GetTransactionsByCategoryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBudgetMonths request
	GetBudgetMonths(ctx context.Context, budgetId string, params *GetBudgetMonthsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBudgetMonth request
	GetBudgetMonth(ctx context.Context, budgetId string, month openapi_types.Date, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMonthCategoryById request
	GetMonthCategoryById(ctx context.Context, budgetId string, month openapi_types.Date, categoryId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateMonthCategoryWithBody request with any body
	UpdateMonthCategoryWithBody(ctx context.Context, budgetId string, month openapi_types.Date, categoryId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateMonthCategory(ctx context.Context, budgetId string, month openapi_types.Date, categoryId string, body UpdateMonthCategoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPayeeLocations request
	GetPayeeLocations(ctx context.Context, budgetId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPayeeLocationById request
	GetPayeeLocationById(ctx context.Context, budgetId string, payeeLocationId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPayees request
	GetPayees(ctx context.Context, budgetId string, params *GetPayeesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPayeeById request
	GetPayeeById(ctx context.Context, budgetId string, payeeId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPayeeLocationsByPayee request
	GetPayeeLocationsByPayee(ctx context.Context, budgetId string, payeeId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTransactionsByPayee request
	GetTransactionsByPayee(ctx context.Context, budgetId string, payeeId string, params *GetTransactionsByPayeeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetScheduledTransactions request
	GetScheduledTransactions(ctx context.Context, budgetId string, params *GetScheduledTransactionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetScheduledTransactionById request
	GetScheduledTransactionById(ctx context.Context, budgetId string, scheduledTransactionId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBudgetSettingsById request
	GetBudgetSettingsById(ctx context.Context, budgetId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTransactions request
	GetTransactions(ctx context.Context, budgetId string, params *GetTransactionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateTransactionsWithBody request with any body
	UpdateTransactionsWithBody(ctx context.Context, budgetId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateTransactions(ctx context.Context, budgetId string, body UpdateTransactionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateTransactionWithBody request with any body
	CreateTransactionWithBody(ctx context.Context, budgetId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateTransaction(ctx context.Context, budgetId string, body CreateTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ImportTransactions request
	ImportTransactions(ctx context.Context, budgetId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTransaction request
	DeleteTransaction(ctx context.Context, budgetId string, transactionId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTransactionById request
	GetTransactionById(ctx context.Context, budgetId string, transactionId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateTransactionWithBody request with any body
	UpdateTransactionWithBody(ctx context.Context, budgetId string, transactionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateTransaction(ctx context.Context, budgetId string, transactionId string, body UpdateTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUser request
	GetUser(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetBudgets(ctx context.Context, params *GetBudgetsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBudgetsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBudgetById(ctx context.Context, budgetId string, params *GetBudgetByIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBudgetByIdRequest(c.Server, budgetId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAccounts(ctx context.Context, budgetId string, params *GetAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAccountsRequest(c.Server, budgetId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAccountWithBody(ctx context.Context, budgetId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAccountRequestWithBody(c.Server, budgetId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAccount(ctx context.Context, budgetId string, body CreateAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAccountRequest(c.Server, budgetId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAccountById(ctx context.Context, budgetId string, accountId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAccountByIdRequest(c.Server, budgetId, accountId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTransactionsByAccount(ctx context.Context, budgetId string, accountId string, params *GetTransactionsByAccountParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTransactionsByAccountRequest(c.Server, budgetId, accountId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCategories(ctx context.Context, budgetId string, params *GetCategoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCategoriesRequest(c.Server, budgetId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCategoryById(ctx context.Context, budgetId string, categoryId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCategoryByIdRequest(c.Server, budgetId, categoryId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCategoryWithBody(ctx context.Context, budgetId string, categoryId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCategoryRequestWithBody(c.Server, budgetId, categoryId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCategory(ctx context.Context, budgetId string, categoryId string, body UpdateCategoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCategoryRequest(c.Server, budgetId, categoryId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTransactionsByCategory(ctx context.Context, budgetId string, categoryId string, params *GetTransactionsByCategoryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTransactionsByCategoryRequest(c.Server, budgetId, categoryId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBudgetMonths(ctx context.Context, budgetId string, params *GetBudgetMonthsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBudgetMonthsRequest(c.Server, budgetId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBudgetMonth(ctx context.Context, budgetId string, month openapi_types.Date, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBudgetMonthRequest(c.Server, budgetId, month)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMonthCategoryById(ctx context.Context, budgetId string, month openapi_types.Date, categoryId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMonthCategoryByIdRequest(c.Server, budgetId, month, categoryId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateMonthCategoryWithBody(ctx context.Context, budgetId string, month openapi_types.Date, categoryId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateMonthCategoryRequestWithBody(c.Server, budgetId, month, categoryId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateMonthCategory(ctx context.Context, budgetId string, month openapi_types.Date, categoryId string, body UpdateMonthCategoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateMonthCategoryRequest(c.Server, budgetId, month, categoryId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPayeeLocations(ctx context.Context, budgetId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPayeeLocationsRequest(c.Server, budgetId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPayeeLocationById(ctx context.Context, budgetId string, payeeLocationId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPayeeLocationByIdRequest(c.Server, budgetId, payeeLocationId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPayees(ctx context.Context, budgetId string, params *GetPayeesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPayeesRequest(c.Server, budgetId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPayeeById(ctx context.Context, budgetId string, payeeId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPayeeByIdRequest(c.Server, budgetId, payeeId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPayeeLocationsByPayee(ctx context.Context, budgetId string, payeeId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPayeeLocationsByPayeeRequest(c.Server, budgetId, payeeId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTransactionsByPayee(ctx context.Context, budgetId string, payeeId string, params *GetTransactionsByPayeeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTransactionsByPayeeRequest(c.Server, budgetId, payeeId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetScheduledTransactions(ctx context.Context, budgetId string, params *GetScheduledTransactionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetScheduledTransactionsRequest(c.Server, budgetId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetScheduledTransactionById(ctx context.Context, budgetId string, scheduledTransactionId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetScheduledTransactionByIdRequest(c.Server, budgetId, scheduledTransactionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBudgetSettingsById(ctx context.Context, budgetId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBudgetSettingsByIdRequest(c.Server, budgetId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTransactions(ctx context.Context, budgetId string, params *GetTransactionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTransactionsRequest(c.Server, budgetId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTransactionsWithBody(ctx context.Context, budgetId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTransactionsRequestWithBody(c.Server, budgetId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTransactions(ctx context.Context, budgetId string, body UpdateTransactionsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTransactionsRequest(c.Server, budgetId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTransactionWithBody(ctx context.Context, budgetId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTransactionRequestWithBody(c.Server, budgetId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateTransaction(ctx context.Context, budgetId string, body CreateTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateTransactionRequest(c.Server, budgetId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ImportTransactions(ctx context.Context, budgetId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewImportTransactionsRequest(c.Server, budgetId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTransaction(ctx context.Context, budgetId string, transactionId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTransactionRequest(c.Server, budgetId, transactionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTransactionById(ctx context.Context, budgetId string, transactionId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTransactionByIdRequest(c.Server, budgetId, transactionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTransactionWithBody(ctx context.Context, budgetId string, transactionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTransactionRequestWithBody(c.Server, budgetId, transactionId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateTransaction(ctx context.Context, budgetId string, transactionId string, body UpdateTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateTransactionRequest(c.Server, budgetId, transactionId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUser(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetBudgetsRequest generates requests for GetBudgets
func NewGetBudgetsRequest(server string, params *GetBudgetsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/budgets")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.IncludeAccounts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "include_accounts", runtime.ParamLocationQuery, *params.IncludeAccounts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBudgetByIdRequest generates requests for GetBudgetById
func NewGetBudgetByIdRequest(server string, budgetId string, params *GetBudgetByIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "budget_id", runtime.ParamLocationPath, budgetId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/budgets/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.LastKnowledgeOfServer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_knowledge_of_server", runtime.ParamLocationQuery, *params.LastKnowledgeOfServer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAccountsRequest generates requests for GetAccounts
func NewGetAccountsRequest(server string, budgetId string, params *GetAccountsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "budget_id", runtime.ParamLocationPath, budgetId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/budgets/%s/accounts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.LastKnowledgeOfServer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_knowledge_of_server", runtime.ParamLocationQuery, *params.LastKnowledgeOfServer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAccountRequest calls the generic CreateAccount builder with application/json body
func NewCreateAccountRequest(server string, budgetId string, body CreateAccountJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAccountRequestWithBody(server, budgetId, "application/json", bodyReader)
}

// NewCreateAccountRequestWithBody generates requests for CreateAccount with any type of body
func NewCreateAccountRequestWithBody(server string, budgetId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "budget_id", runtime.ParamLocationPath, budgetId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/budgets/%s/accounts", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAccountByIdRequest generates requests for GetAccountById
func NewGetAccountByIdRequest(server string, budgetId string, accountId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "budget_id", runtime.ParamLocationPath, budgetId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "account_id", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/budgets/%s/accounts/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTransactionsByAccountRequest generates requests for GetTransactionsByAccount
func NewGetTransactionsByAccountRequest(server string, budgetId string, accountId string, params *GetTransactionsByAccountParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "budget_id", runtime.ParamLocationPath, budgetId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "account_id", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/budgets/%s/accounts/%s/transactions", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SinceDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since_date", runtime.ParamLocationQuery, *params.SinceDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastKnowledgeOfServer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_knowledge_of_server", runtime.ParamLocationQuery, *params.LastKnowledgeOfServer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCategoriesRequest generates requests for GetCategories
func NewGetCategoriesRequest(server string, budgetId string, params *GetCategoriesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "budget_id", runtime.ParamLocationPath, budgetId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/budgets/%s/categories", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.LastKnowledgeOfServer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_knowledge_of_server", runtime.ParamLocationQuery, *params.LastKnowledgeOfServer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCategoryByIdRequest generates requests for GetCategoryById
func NewGetCategoryByIdRequest(server string, budgetId string, categoryId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "budget_id", runtime.ParamLocationPath, budgetId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "category_id", runtime.ParamLocationPath, categoryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/budgets/%s/categories/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateCategoryRequest calls the generic UpdateCategory builder with application/json body
func NewUpdateCategoryRequest(server string, budgetId string, categoryId string, body UpdateCategoryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateCategoryRequestWithBody(server, budgetId, categoryId, "application/json", bodyReader)
}

// NewUpdateCategoryRequestWithBody generates requests for UpdateCategory with any type of body
func NewUpdateCategoryRequestWithBody(server string, budgetId string, categoryId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "budget_id", runtime.ParamLocationPath, budgetId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "category_id", runtime.ParamLocationPath, categoryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/budgets/%s/categories/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetTransactionsByCategoryRequest generates requests for GetTransactionsByCategory
func NewGetTransactionsByCategoryRequest(server string, budgetId string, categoryId string, params *GetTransactionsByCategoryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "budget_id", runtime.ParamLocationPath, budgetId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "category_id", runtime.ParamLocationPath, categoryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/budgets/%s/categories/%s/transactions", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SinceDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since_date", runtime.ParamLocationQuery, *params.SinceDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastKnowledgeOfServer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_knowledge_of_server", runtime.ParamLocationQuery, *params.LastKnowledgeOfServer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBudgetMonthsRequest generates requests for GetBudgetMonths
func NewGetBudgetMonthsRequest(server string, budgetId string, params *GetBudgetMonthsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "budget_id", runtime.ParamLocationPath, budgetId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/budgets/%s/months", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.LastKnowledgeOfServer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_knowledge_of_server", runtime.ParamLocationQuery, *params.LastKnowledgeOfServer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBudgetMonthRequest generates requests for GetBudgetMonth
func NewGetBudgetMonthRequest(server string, budgetId string, month openapi_types.Date) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "budget_id", runtime.ParamLocationPath, budgetId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "month", runtime.ParamLocationPath, month)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/budgets/%s/months/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMonthCategoryByIdRequest generates requests for GetMonthCategoryById
func NewGetMonthCategoryByIdRequest(server string, budgetId string, month openapi_types.Date, categoryId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "budget_id", runtime.ParamLocationPath, budgetId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "month", runtime.ParamLocationPath, month)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "category_id", runtime.ParamLocationPath, categoryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/budgets/%s/months/%s/categories/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateMonthCategoryRequest calls the generic UpdateMonthCategory builder with application/json body
func NewUpdateMonthCategoryRequest(server string, budgetId string, month openapi_types.Date, categoryId string, body UpdateMonthCategoryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateMonthCategoryRequestWithBody(server, budgetId, month, categoryId, "application/json", bodyReader)
}

// NewUpdateMonthCategoryRequestWithBody generates requests for UpdateMonthCategory with any type of body
func NewUpdateMonthCategoryRequestWithBody(server string, budgetId string, month openapi_types.Date, categoryId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "budget_id", runtime.ParamLocationPath, budgetId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "month", runtime.ParamLocationPath, month)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "category_id", runtime.ParamLocationPath, categoryId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/budgets/%s/months/%s/categories/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPayeeLocationsRequest generates requests for GetPayeeLocations
func NewGetPayeeLocationsRequest(server string, budgetId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "budget_id", runtime.ParamLocationPath, budgetId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/budgets/%s/payee_locations", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPayeeLocationByIdRequest generates requests for GetPayeeLocationById
func NewGetPayeeLocationByIdRequest(server string, budgetId string, payeeLocationId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "budget_id", runtime.ParamLocationPath, budgetId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "payee_location_id", runtime.ParamLocationPath, payeeLocationId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/budgets/%s/payee_locations/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPayeesRequest generates requests for GetPayees
func NewGetPayeesRequest(server string, budgetId string, params *GetPayeesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "budget_id", runtime.ParamLocationPath, budgetId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/budgets/%s/payees", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.LastKnowledgeOfServer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_knowledge_of_server", runtime.ParamLocationQuery, *params.LastKnowledgeOfServer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPayeeByIdRequest generates requests for GetPayeeById
func NewGetPayeeByIdRequest(server string, budgetId string, payeeId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "budget_id", runtime.ParamLocationPath, budgetId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "payee_id", runtime.ParamLocationPath, payeeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/budgets/%s/payees/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPayeeLocationsByPayeeRequest generates requests for GetPayeeLocationsByPayee
func NewGetPayeeLocationsByPayeeRequest(server string, budgetId string, payeeId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "budget_id", runtime.ParamLocationPath, budgetId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "payee_id", runtime.ParamLocationPath, payeeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/budgets/%s/payees/%s/payee_locations", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTransactionsByPayeeRequest generates requests for GetTransactionsByPayee
func NewGetTransactionsByPayeeRequest(server string, budgetId string, payeeId string, params *GetTransactionsByPayeeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "budget_id", runtime.ParamLocationPath, budgetId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "payee_id", runtime.ParamLocationPath, payeeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/budgets/%s/payees/%s/transactions", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SinceDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since_date", runtime.ParamLocationQuery, *params.SinceDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastKnowledgeOfServer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_knowledge_of_server", runtime.ParamLocationQuery, *params.LastKnowledgeOfServer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetScheduledTransactionsRequest generates requests for GetScheduledTransactions
func NewGetScheduledTransactionsRequest(server string, budgetId string, params *GetScheduledTransactionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "budget_id", runtime.ParamLocationPath, budgetId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/budgets/%s/scheduled_transactions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.LastKnowledgeOfServer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_knowledge_of_server", runtime.ParamLocationQuery, *params.LastKnowledgeOfServer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetScheduledTransactionByIdRequest generates requests for GetScheduledTransactionById
func NewGetScheduledTransactionByIdRequest(server string, budgetId string, scheduledTransactionId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "budget_id", runtime.ParamLocationPath, budgetId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "scheduled_transaction_id", runtime.ParamLocationPath, scheduledTransactionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/budgets/%s/scheduled_transactions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBudgetSettingsByIdRequest generates requests for GetBudgetSettingsById
func NewGetBudgetSettingsByIdRequest(server string, budgetId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "budget_id", runtime.ParamLocationPath, budgetId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/budgets/%s/settings", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTransactionsRequest generates requests for GetTransactions
func NewGetTransactionsRequest(server string, budgetId string, params *GetTransactionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "budget_id", runtime.ParamLocationPath, budgetId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/budgets/%s/transactions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SinceDate != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since_date", runtime.ParamLocationQuery, *params.SinceDate); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LastKnowledgeOfServer != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "last_knowledge_of_server", runtime.ParamLocationQuery, *params.LastKnowledgeOfServer); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateTransactionsRequest calls the generic UpdateTransactions builder with application/json body
func NewUpdateTransactionsRequest(server string, budgetId string, body UpdateTransactionsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateTransactionsRequestWithBody(server, budgetId, "application/json", bodyReader)
}

// NewUpdateTransactionsRequestWithBody generates requests for UpdateTransactions with any type of body
func NewUpdateTransactionsRequestWithBody(server string, budgetId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "budget_id", runtime.ParamLocationPath, budgetId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/budgets/%s/transactions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateTransactionRequest calls the generic CreateTransaction builder with application/json body
func NewCreateTransactionRequest(server string, budgetId string, body CreateTransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateTransactionRequestWithBody(server, budgetId, "application/json", bodyReader)
}

// NewCreateTransactionRequestWithBody generates requests for CreateTransaction with any type of body
func NewCreateTransactionRequestWithBody(server string, budgetId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "budget_id", runtime.ParamLocationPath, budgetId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/budgets/%s/transactions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewImportTransactionsRequest generates requests for ImportTransactions
func NewImportTransactionsRequest(server string, budgetId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "budget_id", runtime.ParamLocationPath, budgetId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/budgets/%s/transactions/import", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteTransactionRequest generates requests for DeleteTransaction
func NewDeleteTransactionRequest(server string, budgetId string, transactionId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "budget_id", runtime.ParamLocationPath, budgetId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "transaction_id", runtime.ParamLocationPath, transactionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/budgets/%s/transactions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTransactionByIdRequest generates requests for GetTransactionById
func NewGetTransactionByIdRequest(server string, budgetId string, transactionId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "budget_id", runtime.ParamLocationPath, budgetId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "transaction_id", runtime.ParamLocationPath, transactionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/budgets/%s/transactions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateTransactionRequest calls the generic UpdateTransaction builder with application/json body
func NewUpdateTransactionRequest(server string, budgetId string, transactionId string, body UpdateTransactionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateTransactionRequestWithBody(server, budgetId, transactionId, "application/json", bodyReader)
}

// NewUpdateTransactionRequestWithBody generates requests for UpdateTransaction with any type of body
func NewUpdateTransactionRequestWithBody(server string, budgetId string, transactionId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "budget_id", runtime.ParamLocationPath, budgetId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "transaction_id", runtime.ParamLocationPath, transactionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/budgets/%s/transactions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUserRequest generates requests for GetUser
func NewGetUserRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetBudgetsWithResponse request
	GetBudgetsWithResponse(ctx context.Context, params *GetBudgetsParams, reqEditors ...RequestEditorFn) (*GetBudgetsResponse, error)

	// GetBudgetByIdWithResponse request
	GetBudgetByIdWithResponse(ctx context.Context, budgetId string, params *GetBudgetByIdParams, reqEditors ...RequestEditorFn) (*GetBudgetByIdResponse, error)

	// GetAccountsWithResponse request
	GetAccountsWithResponse(ctx context.Context, budgetId string, params *GetAccountsParams, reqEditors ...RequestEditorFn) (*GetAccountsResponse, error)

	// CreateAccountWithBodyWithResponse request with any body
	CreateAccountWithBodyWithResponse(ctx context.Context, budgetId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAccountResponse, error)

	CreateAccountWithResponse(ctx context.Context, budgetId string, body CreateAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAccountResponse, error)

	// GetAccountByIdWithResponse request
	GetAccountByIdWithResponse(ctx context.Context, budgetId string, accountId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetAccountByIdResponse, error)

	// GetTransactionsByAccountWithResponse request
	GetTransactionsByAccountWithResponse(ctx context.Context, budgetId string, accountId string, params *GetTransactionsByAccountParams, reqEditors ...RequestEditorFn) (*GetTransactionsByAccountResponse, error)

	// GetCategoriesWithResponse request
	GetCategoriesWithResponse(ctx context.Context, budgetId string, params *GetCategoriesParams, reqEditors ...RequestEditorFn) (*GetCategoriesResponse, error)

	// GetCategoryByIdWithResponse request
	GetCategoryByIdWithResponse(ctx context.Context, budgetId string, categoryId string, reqEditors ...RequestEditorFn) (*GetCategoryByIdResponse, error)

	// UpdateCategoryWithBodyWithResponse request with any body
	UpdateCategoryWithBodyWithResponse(ctx context.Context, budgetId string, categoryId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCategoryResponse, error)

	UpdateCategoryWithResponse(ctx context.Context, budgetId string, categoryId string, body UpdateCategoryJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCategoryResponse, error)

	// GetTransactionsByCategoryWithResponse request
	GetTransactionsByCategoryWithResponse(ctx context.Context, budgetId string, categoryId string, params *GetTransactionsByCategoryParams, reqEditors ...RequestEditorFn) (*GetTransactionsByCategoryResponse, error)

	// GetBudgetMonthsWithResponse request
	GetBudgetMonthsWithResponse(ctx context.Context, budgetId string, params *GetBudgetMonthsParams, reqEditors ...RequestEditorFn) (*GetBudgetMonthsResponse, error)

	// GetBudgetMonthWithResponse request
	GetBudgetMonthWithResponse(ctx context.Context, budgetId string, month openapi_types.Date, reqEditors ...RequestEditorFn) (*GetBudgetMonthResponse, error)

	// GetMonthCategoryByIdWithResponse request
	GetMonthCategoryByIdWithResponse(ctx context.Context, budgetId string, month openapi_types.Date, categoryId string, reqEditors ...RequestEditorFn) (*GetMonthCategoryByIdResponse, error)

	// UpdateMonthCategoryWithBodyWithResponse request with any body
	UpdateMonthCategoryWithBodyWithResponse(ctx context.Context, budgetId string, month openapi_types.Date, categoryId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateMonthCategoryResponse, error)

	UpdateMonthCategoryWithResponse(ctx context.Context, budgetId string, month openapi_types.Date, categoryId string, body UpdateMonthCategoryJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateMonthCategoryResponse, error)

	// GetPayeeLocationsWithResponse request
	GetPayeeLocationsWithResponse(ctx context.Context, budgetId string, reqEditors ...RequestEditorFn) (*GetPayeeLocationsResponse, error)

	// GetPayeeLocationByIdWithResponse request
	GetPayeeLocationByIdWithResponse(ctx context.Context, budgetId string, payeeLocationId string, reqEditors ...RequestEditorFn) (*GetPayeeLocationByIdResponse, error)

	// GetPayeesWithResponse request
	GetPayeesWithResponse(ctx context.Context, budgetId string, params *GetPayeesParams, reqEditors ...RequestEditorFn) (*GetPayeesResponse, error)

	// GetPayeeByIdWithResponse request
	GetPayeeByIdWithResponse(ctx context.Context, budgetId string, payeeId string, reqEditors ...RequestEditorFn) (*GetPayeeByIdResponse, error)

	// GetPayeeLocationsByPayeeWithResponse request
	GetPayeeLocationsByPayeeWithResponse(ctx context.Context, budgetId string, payeeId string, reqEditors ...RequestEditorFn) (*GetPayeeLocationsByPayeeResponse, error)

	// GetTransactionsByPayeeWithResponse request
	GetTransactionsByPayeeWithResponse(ctx context.Context, budgetId string, payeeId string, params *GetTransactionsByPayeeParams, reqEditors ...RequestEditorFn) (*GetTransactionsByPayeeResponse, error)

	// GetScheduledTransactionsWithResponse request
	GetScheduledTransactionsWithResponse(ctx context.Context, budgetId string, params *GetScheduledTransactionsParams, reqEditors ...RequestEditorFn) (*GetScheduledTransactionsResponse, error)

	// GetScheduledTransactionByIdWithResponse request
	GetScheduledTransactionByIdWithResponse(ctx context.Context, budgetId string, scheduledTransactionId string, reqEditors ...RequestEditorFn) (*GetScheduledTransactionByIdResponse, error)

	// GetBudgetSettingsByIdWithResponse request
	GetBudgetSettingsByIdWithResponse(ctx context.Context, budgetId string, reqEditors ...RequestEditorFn) (*GetBudgetSettingsByIdResponse, error)

	// GetTransactionsWithResponse request
	GetTransactionsWithResponse(ctx context.Context, budgetId string, params *GetTransactionsParams, reqEditors ...RequestEditorFn) (*GetTransactionsResponse, error)

	// UpdateTransactionsWithBodyWithResponse request with any body
	UpdateTransactionsWithBodyWithResponse(ctx context.Context, budgetId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTransactionsResponse, error)

	UpdateTransactionsWithResponse(ctx context.Context, budgetId string, body UpdateTransactionsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTransactionsResponse, error)

	// CreateTransactionWithBodyWithResponse request with any body
	CreateTransactionWithBodyWithResponse(ctx context.Context, budgetId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTransactionResponse, error)

	CreateTransactionWithResponse(ctx context.Context, budgetId string, body CreateTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTransactionResponse, error)

	// ImportTransactionsWithResponse request
	ImportTransactionsWithResponse(ctx context.Context, budgetId string, reqEditors ...RequestEditorFn) (*ImportTransactionsResponse, error)

	// DeleteTransactionWithResponse request
	DeleteTransactionWithResponse(ctx context.Context, budgetId string, transactionId string, reqEditors ...RequestEditorFn) (*DeleteTransactionResponse, error)

	// GetTransactionByIdWithResponse request
	GetTransactionByIdWithResponse(ctx context.Context, budgetId string, transactionId string, reqEditors ...RequestEditorFn) (*GetTransactionByIdResponse, error)

	// UpdateTransactionWithBodyWithResponse request with any body
	UpdateTransactionWithBodyWithResponse(ctx context.Context, budgetId string, transactionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTransactionResponse, error)

	UpdateTransactionWithResponse(ctx context.Context, budgetId string, transactionId string, body UpdateTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTransactionResponse, error)

	// GetUserWithResponse request
	GetUserWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUserResponse, error)
}

type GetBudgetsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BudgetSummaryResponse
	JSON404      *ErrorResponse
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetBudgetsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBudgetsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBudgetByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BudgetDetailResponse
	JSON404      *ErrorResponse
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetBudgetByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBudgetByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AccountsResponse
	JSON404      *ErrorResponse
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *AccountResponse
	JSON400      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r CreateAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAccountByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AccountResponse
	JSON404      *ErrorResponse
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetAccountByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAccountByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTransactionsByAccountResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TransactionsResponse
	JSON404      *ErrorResponse
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetTransactionsByAccountResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTransactionsByAccountResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCategoriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CategoriesResponse
	JSON404      *ErrorResponse
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetCategoriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCategoriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCategoryByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CategoryResponse
	JSON404      *ErrorResponse
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetCategoryByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCategoryByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateCategoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SaveCategoryResponse
	JSON400      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r UpdateCategoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateCategoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTransactionsByCategoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HybridTransactionsResponse
	JSON404      *ErrorResponse
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetTransactionsByCategoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTransactionsByCategoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBudgetMonthsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MonthSummariesResponse
	JSON404      *ErrorResponse
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetBudgetMonthsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBudgetMonthsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBudgetMonthResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MonthDetailResponse
	JSON404      *ErrorResponse
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetBudgetMonthResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBudgetMonthResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMonthCategoryByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CategoryResponse
	JSON404      *ErrorResponse
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetMonthCategoryByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMonthCategoryByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateMonthCategoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *SaveCategoryResponse
	JSON400      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r UpdateMonthCategoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateMonthCategoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPayeeLocationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PayeeLocationsResponse
	JSON404      *ErrorResponse
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetPayeeLocationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPayeeLocationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPayeeLocationByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PayeeLocationResponse
	JSON404      *ErrorResponse
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetPayeeLocationByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPayeeLocationByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPayeesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PayeesResponse
	JSON404      *ErrorResponse
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetPayeesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPayeesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPayeeByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PayeeResponse
	JSON404      *ErrorResponse
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetPayeeByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPayeeByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPayeeLocationsByPayeeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PayeeLocationsResponse
	JSON404      *ErrorResponse
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetPayeeLocationsByPayeeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPayeeLocationsByPayeeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTransactionsByPayeeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HybridTransactionsResponse
	JSON404      *ErrorResponse
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetTransactionsByPayeeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTransactionsByPayeeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetScheduledTransactionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ScheduledTransactionsResponse
	JSON404      *ErrorResponse
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetScheduledTransactionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetScheduledTransactionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetScheduledTransactionByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ScheduledTransactionResponse
	JSON404      *ErrorResponse
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetScheduledTransactionByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetScheduledTransactionByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBudgetSettingsByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BudgetSettingsResponse
	JSON404      *ErrorResponse
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetBudgetSettingsByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBudgetSettingsByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTransactionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TransactionsResponse
	JSON400      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetTransactionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTransactionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateTransactionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON209      *SaveTransactionsResponse
	JSON400      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r UpdateTransactionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateTransactionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *SaveTransactionsResponse
	JSON400      *ErrorResponse
	JSON409      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r CreateTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ImportTransactionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TransactionsImportResponse
	JSON201      *TransactionsImportResponse
	JSON400      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ImportTransactionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ImportTransactionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TransactionResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeleteTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTransactionByIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TransactionResponse
	JSON404      *ErrorResponse
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetTransactionByIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTransactionByIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateTransactionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TransactionResponse
	JSON400      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r UpdateTransactionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateTransactionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserResponse
	JSONDefault  *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetBudgetsWithResponse request returning *GetBudgetsResponse
func (c *ClientWithResponses) GetBudgetsWithResponse(ctx context.Context, params *GetBudgetsParams, reqEditors ...RequestEditorFn) (*GetBudgetsResponse, error) {
	rsp, err := c.GetBudgets(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBudgetsResponse(rsp)
}

// GetBudgetByIdWithResponse request returning *GetBudgetByIdResponse
func (c *ClientWithResponses) GetBudgetByIdWithResponse(ctx context.Context, budgetId string, params *GetBudgetByIdParams, reqEditors ...RequestEditorFn) (*GetBudgetByIdResponse, error) {
	rsp, err := c.GetBudgetById(ctx, budgetId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBudgetByIdResponse(rsp)
}

// GetAccountsWithResponse request returning *GetAccountsResponse
func (c *ClientWithResponses) GetAccountsWithResponse(ctx context.Context, budgetId string, params *GetAccountsParams, reqEditors ...RequestEditorFn) (*GetAccountsResponse, error) {
	rsp, err := c.GetAccounts(ctx, budgetId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAccountsResponse(rsp)
}

// CreateAccountWithBodyWithResponse request with arbitrary body returning *CreateAccountResponse
func (c *ClientWithResponses) CreateAccountWithBodyWithResponse(ctx context.Context, budgetId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAccountResponse, error) {
	rsp, err := c.CreateAccountWithBody(ctx, budgetId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAccountResponse(rsp)
}

func (c *ClientWithResponses) CreateAccountWithResponse(ctx context.Context, budgetId string, body CreateAccountJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAccountResponse, error) {
	rsp, err := c.CreateAccount(ctx, budgetId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAccountResponse(rsp)
}

// GetAccountByIdWithResponse request returning *GetAccountByIdResponse
func (c *ClientWithResponses) GetAccountByIdWithResponse(ctx context.Context, budgetId string, accountId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetAccountByIdResponse, error) {
	rsp, err := c.GetAccountById(ctx, budgetId, accountId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAccountByIdResponse(rsp)
}

// GetTransactionsByAccountWithResponse request returning *GetTransactionsByAccountResponse
func (c *ClientWithResponses) GetTransactionsByAccountWithResponse(ctx context.Context, budgetId string, accountId string, params *GetTransactionsByAccountParams, reqEditors ...RequestEditorFn) (*GetTransactionsByAccountResponse, error) {
	rsp, err := c.GetTransactionsByAccount(ctx, budgetId, accountId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTransactionsByAccountResponse(rsp)
}

// GetCategoriesWithResponse request returning *GetCategoriesResponse
func (c *ClientWithResponses) GetCategoriesWithResponse(ctx context.Context, budgetId string, params *GetCategoriesParams, reqEditors ...RequestEditorFn) (*GetCategoriesResponse, error) {
	rsp, err := c.GetCategories(ctx, budgetId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCategoriesResponse(rsp)
}

// GetCategoryByIdWithResponse request returning *GetCategoryByIdResponse
func (c *ClientWithResponses) GetCategoryByIdWithResponse(ctx context.Context, budgetId string, categoryId string, reqEditors ...RequestEditorFn) (*GetCategoryByIdResponse, error) {
	rsp, err := c.GetCategoryById(ctx, budgetId, categoryId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCategoryByIdResponse(rsp)
}

// UpdateCategoryWithBodyWithResponse request with arbitrary body returning *UpdateCategoryResponse
func (c *ClientWithResponses) UpdateCategoryWithBodyWithResponse(ctx context.Context, budgetId string, categoryId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCategoryResponse, error) {
	rsp, err := c.UpdateCategoryWithBody(ctx, budgetId, categoryId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCategoryResponse(rsp)
}

func (c *ClientWithResponses) UpdateCategoryWithResponse(ctx context.Context, budgetId string, categoryId string, body UpdateCategoryJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCategoryResponse, error) {
	rsp, err := c.UpdateCategory(ctx, budgetId, categoryId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCategoryResponse(rsp)
}

// GetTransactionsByCategoryWithResponse request returning *GetTransactionsByCategoryResponse
func (c *ClientWithResponses) GetTransactionsByCategoryWithResponse(ctx context.Context, budgetId string, categoryId string, params *GetTransactionsByCategoryParams, reqEditors ...RequestEditorFn) (*GetTransactionsByCategoryResponse, error) {
	rsp, err := c.GetTransactionsByCategory(ctx, budgetId, categoryId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTransactionsByCategoryResponse(rsp)
}

// GetBudgetMonthsWithResponse request returning *GetBudgetMonthsResponse
func (c *ClientWithResponses) GetBudgetMonthsWithResponse(ctx context.Context, budgetId string, params *GetBudgetMonthsParams, reqEditors ...RequestEditorFn) (*GetBudgetMonthsResponse, error) {
	rsp, err := c.GetBudgetMonths(ctx, budgetId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBudgetMonthsResponse(rsp)
}

// GetBudgetMonthWithResponse request returning *GetBudgetMonthResponse
func (c *ClientWithResponses) GetBudgetMonthWithResponse(ctx context.Context, budgetId string, month openapi_types.Date, reqEditors ...RequestEditorFn) (*GetBudgetMonthResponse, error) {
	rsp, err := c.GetBudgetMonth(ctx, budgetId, month, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBudgetMonthResponse(rsp)
}

// GetMonthCategoryByIdWithResponse request returning *GetMonthCategoryByIdResponse
func (c *ClientWithResponses) GetMonthCategoryByIdWithResponse(ctx context.Context, budgetId string, month openapi_types.Date, categoryId string, reqEditors ...RequestEditorFn) (*GetMonthCategoryByIdResponse, error) {
	rsp, err := c.GetMonthCategoryById(ctx, budgetId, month, categoryId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMonthCategoryByIdResponse(rsp)
}

// UpdateMonthCategoryWithBodyWithResponse request with arbitrary body returning *UpdateMonthCategoryResponse
func (c *ClientWithResponses) UpdateMonthCategoryWithBodyWithResponse(ctx context.Context, budgetId string, month openapi_types.Date, categoryId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateMonthCategoryResponse, error) {
	rsp, err := c.UpdateMonthCategoryWithBody(ctx, budgetId, month, categoryId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateMonthCategoryResponse(rsp)
}

func (c *ClientWithResponses) UpdateMonthCategoryWithResponse(ctx context.Context, budgetId string, month openapi_types.Date, categoryId string, body UpdateMonthCategoryJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateMonthCategoryResponse, error) {
	rsp, err := c.UpdateMonthCategory(ctx, budgetId, month, categoryId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateMonthCategoryResponse(rsp)
}

// GetPayeeLocationsWithResponse request returning *GetPayeeLocationsResponse
func (c *ClientWithResponses) GetPayeeLocationsWithResponse(ctx context.Context, budgetId string, reqEditors ...RequestEditorFn) (*GetPayeeLocationsResponse, error) {
	rsp, err := c.GetPayeeLocations(ctx, budgetId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPayeeLocationsResponse(rsp)
}

// GetPayeeLocationByIdWithResponse request returning *GetPayeeLocationByIdResponse
func (c *ClientWithResponses) GetPayeeLocationByIdWithResponse(ctx context.Context, budgetId string, payeeLocationId string, reqEditors ...RequestEditorFn) (*GetPayeeLocationByIdResponse, error) {
	rsp, err := c.GetPayeeLocationById(ctx, budgetId, payeeLocationId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPayeeLocationByIdResponse(rsp)
}

// GetPayeesWithResponse request returning *GetPayeesResponse
func (c *ClientWithResponses) GetPayeesWithResponse(ctx context.Context, budgetId string, params *GetPayeesParams, reqEditors ...RequestEditorFn) (*GetPayeesResponse, error) {
	rsp, err := c.GetPayees(ctx, budgetId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPayeesResponse(rsp)
}

// GetPayeeByIdWithResponse request returning *GetPayeeByIdResponse
func (c *ClientWithResponses) GetPayeeByIdWithResponse(ctx context.Context, budgetId string, payeeId string, reqEditors ...RequestEditorFn) (*GetPayeeByIdResponse, error) {
	rsp, err := c.GetPayeeById(ctx, budgetId, payeeId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPayeeByIdResponse(rsp)
}

// GetPayeeLocationsByPayeeWithResponse request returning *GetPayeeLocationsByPayeeResponse
func (c *ClientWithResponses) GetPayeeLocationsByPayeeWithResponse(ctx context.Context, budgetId string, payeeId string, reqEditors ...RequestEditorFn) (*GetPayeeLocationsByPayeeResponse, error) {
	rsp, err := c.GetPayeeLocationsByPayee(ctx, budgetId, payeeId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPayeeLocationsByPayeeResponse(rsp)
}

// GetTransactionsByPayeeWithResponse request returning *GetTransactionsByPayeeResponse
func (c *ClientWithResponses) GetTransactionsByPayeeWithResponse(ctx context.Context, budgetId string, payeeId string, params *GetTransactionsByPayeeParams, reqEditors ...RequestEditorFn) (*GetTransactionsByPayeeResponse, error) {
	rsp, err := c.GetTransactionsByPayee(ctx, budgetId, payeeId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTransactionsByPayeeResponse(rsp)
}

// GetScheduledTransactionsWithResponse request returning *GetScheduledTransactionsResponse
func (c *ClientWithResponses) GetScheduledTransactionsWithResponse(ctx context.Context, budgetId string, params *GetScheduledTransactionsParams, reqEditors ...RequestEditorFn) (*GetScheduledTransactionsResponse, error) {
	rsp, err := c.GetScheduledTransactions(ctx, budgetId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetScheduledTransactionsResponse(rsp)
}

// GetScheduledTransactionByIdWithResponse request returning *GetScheduledTransactionByIdResponse
func (c *ClientWithResponses) GetScheduledTransactionByIdWithResponse(ctx context.Context, budgetId string, scheduledTransactionId string, reqEditors ...RequestEditorFn) (*GetScheduledTransactionByIdResponse, error) {
	rsp, err := c.GetScheduledTransactionById(ctx, budgetId, scheduledTransactionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetScheduledTransactionByIdResponse(rsp)
}

// GetBudgetSettingsByIdWithResponse request returning *GetBudgetSettingsByIdResponse
func (c *ClientWithResponses) GetBudgetSettingsByIdWithResponse(ctx context.Context, budgetId string, reqEditors ...RequestEditorFn) (*GetBudgetSettingsByIdResponse, error) {
	rsp, err := c.GetBudgetSettingsById(ctx, budgetId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBudgetSettingsByIdResponse(rsp)
}

// GetTransactionsWithResponse request returning *GetTransactionsResponse
func (c *ClientWithResponses) GetTransactionsWithResponse(ctx context.Context, budgetId string, params *GetTransactionsParams, reqEditors ...RequestEditorFn) (*GetTransactionsResponse, error) {
	rsp, err := c.GetTransactions(ctx, budgetId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTransactionsResponse(rsp)
}

// UpdateTransactionsWithBodyWithResponse request with arbitrary body returning *UpdateTransactionsResponse
func (c *ClientWithResponses) UpdateTransactionsWithBodyWithResponse(ctx context.Context, budgetId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTransactionsResponse, error) {
	rsp, err := c.UpdateTransactionsWithBody(ctx, budgetId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTransactionsResponse(rsp)
}

func (c *ClientWithResponses) UpdateTransactionsWithResponse(ctx context.Context, budgetId string, body UpdateTransactionsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTransactionsResponse, error) {
	rsp, err := c.UpdateTransactions(ctx, budgetId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTransactionsResponse(rsp)
}

// CreateTransactionWithBodyWithResponse request with arbitrary body returning *CreateTransactionResponse
func (c *ClientWithResponses) CreateTransactionWithBodyWithResponse(ctx context.Context, budgetId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateTransactionResponse, error) {
	rsp, err := c.CreateTransactionWithBody(ctx, budgetId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTransactionResponse(rsp)
}

func (c *ClientWithResponses) CreateTransactionWithResponse(ctx context.Context, budgetId string, body CreateTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateTransactionResponse, error) {
	rsp, err := c.CreateTransaction(ctx, budgetId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateTransactionResponse(rsp)
}

// ImportTransactionsWithResponse request returning *ImportTransactionsResponse
func (c *ClientWithResponses) ImportTransactionsWithResponse(ctx context.Context, budgetId string, reqEditors ...RequestEditorFn) (*ImportTransactionsResponse, error) {
	rsp, err := c.ImportTransactions(ctx, budgetId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseImportTransactionsResponse(rsp)
}

// DeleteTransactionWithResponse request returning *DeleteTransactionResponse
func (c *ClientWithResponses) DeleteTransactionWithResponse(ctx context.Context, budgetId string, transactionId string, reqEditors ...RequestEditorFn) (*DeleteTransactionResponse, error) {
	rsp, err := c.DeleteTransaction(ctx, budgetId, transactionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTransactionResponse(rsp)
}

// GetTransactionByIdWithResponse request returning *GetTransactionByIdResponse
func (c *ClientWithResponses) GetTransactionByIdWithResponse(ctx context.Context, budgetId string, transactionId string, reqEditors ...RequestEditorFn) (*GetTransactionByIdResponse, error) {
	rsp, err := c.GetTransactionById(ctx, budgetId, transactionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTransactionByIdResponse(rsp)
}

// UpdateTransactionWithBodyWithResponse request with arbitrary body returning *UpdateTransactionResponse
func (c *ClientWithResponses) UpdateTransactionWithBodyWithResponse(ctx context.Context, budgetId string, transactionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateTransactionResponse, error) {
	rsp, err := c.UpdateTransactionWithBody(ctx, budgetId, transactionId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTransactionResponse(rsp)
}

func (c *ClientWithResponses) UpdateTransactionWithResponse(ctx context.Context, budgetId string, transactionId string, body UpdateTransactionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateTransactionResponse, error) {
	rsp, err := c.UpdateTransaction(ctx, budgetId, transactionId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateTransactionResponse(rsp)
}

// GetUserWithResponse request returning *GetUserResponse
func (c *ClientWithResponses) GetUserWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUserResponse, error) {
	rsp, err := c.GetUser(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserResponse(rsp)
}

// ParseGetBudgetsResponse parses an HTTP response from a GetBudgetsWithResponse call
func ParseGetBudgetsResponse(rsp *http.Response) (*GetBudgetsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBudgetsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BudgetSummaryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetBudgetByIdResponse parses an HTTP response from a GetBudgetByIdWithResponse call
func ParseGetBudgetByIdResponse(rsp *http.Response) (*GetBudgetByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBudgetByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BudgetDetailResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetAccountsResponse parses an HTTP response from a GetAccountsWithResponse call
func ParseGetAccountsResponse(rsp *http.Response) (*GetAccountsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AccountsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseCreateAccountResponse parses an HTTP response from a CreateAccountWithResponse call
func ParseCreateAccountResponse(rsp *http.Response) (*CreateAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest AccountResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetAccountByIdResponse parses an HTTP response from a GetAccountByIdWithResponse call
func ParseGetAccountByIdResponse(rsp *http.Response) (*GetAccountByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAccountByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AccountResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetTransactionsByAccountResponse parses an HTTP response from a GetTransactionsByAccountWithResponse call
func ParseGetTransactionsByAccountResponse(rsp *http.Response) (*GetTransactionsByAccountResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTransactionsByAccountResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TransactionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetCategoriesResponse parses an HTTP response from a GetCategoriesWithResponse call
func ParseGetCategoriesResponse(rsp *http.Response) (*GetCategoriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCategoriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CategoriesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetCategoryByIdResponse parses an HTTP response from a GetCategoryByIdWithResponse call
func ParseGetCategoryByIdResponse(rsp *http.Response) (*GetCategoryByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCategoryByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CategoryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateCategoryResponse parses an HTTP response from a UpdateCategoryWithResponse call
func ParseUpdateCategoryResponse(rsp *http.Response) (*UpdateCategoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateCategoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SaveCategoryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetTransactionsByCategoryResponse parses an HTTP response from a GetTransactionsByCategoryWithResponse call
func ParseGetTransactionsByCategoryResponse(rsp *http.Response) (*GetTransactionsByCategoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTransactionsByCategoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HybridTransactionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetBudgetMonthsResponse parses an HTTP response from a GetBudgetMonthsWithResponse call
func ParseGetBudgetMonthsResponse(rsp *http.Response) (*GetBudgetMonthsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBudgetMonthsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MonthSummariesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetBudgetMonthResponse parses an HTTP response from a GetBudgetMonthWithResponse call
func ParseGetBudgetMonthResponse(rsp *http.Response) (*GetBudgetMonthResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBudgetMonthResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MonthDetailResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetMonthCategoryByIdResponse parses an HTTP response from a GetMonthCategoryByIdWithResponse call
func ParseGetMonthCategoryByIdResponse(rsp *http.Response) (*GetMonthCategoryByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMonthCategoryByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CategoryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateMonthCategoryResponse parses an HTTP response from a UpdateMonthCategoryWithResponse call
func ParseUpdateMonthCategoryResponse(rsp *http.Response) (*UpdateMonthCategoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateMonthCategoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest SaveCategoryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetPayeeLocationsResponse parses an HTTP response from a GetPayeeLocationsWithResponse call
func ParseGetPayeeLocationsResponse(rsp *http.Response) (*GetPayeeLocationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPayeeLocationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PayeeLocationsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetPayeeLocationByIdResponse parses an HTTP response from a GetPayeeLocationByIdWithResponse call
func ParseGetPayeeLocationByIdResponse(rsp *http.Response) (*GetPayeeLocationByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPayeeLocationByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PayeeLocationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetPayeesResponse parses an HTTP response from a GetPayeesWithResponse call
func ParseGetPayeesResponse(rsp *http.Response) (*GetPayeesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPayeesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PayeesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetPayeeByIdResponse parses an HTTP response from a GetPayeeByIdWithResponse call
func ParseGetPayeeByIdResponse(rsp *http.Response) (*GetPayeeByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPayeeByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PayeeResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetPayeeLocationsByPayeeResponse parses an HTTP response from a GetPayeeLocationsByPayeeWithResponse call
func ParseGetPayeeLocationsByPayeeResponse(rsp *http.Response) (*GetPayeeLocationsByPayeeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPayeeLocationsByPayeeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PayeeLocationsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetTransactionsByPayeeResponse parses an HTTP response from a GetTransactionsByPayeeWithResponse call
func ParseGetTransactionsByPayeeResponse(rsp *http.Response) (*GetTransactionsByPayeeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTransactionsByPayeeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HybridTransactionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetScheduledTransactionsResponse parses an HTTP response from a GetScheduledTransactionsWithResponse call
func ParseGetScheduledTransactionsResponse(rsp *http.Response) (*GetScheduledTransactionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetScheduledTransactionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ScheduledTransactionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetScheduledTransactionByIdResponse parses an HTTP response from a GetScheduledTransactionByIdWithResponse call
func ParseGetScheduledTransactionByIdResponse(rsp *http.Response) (*GetScheduledTransactionByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetScheduledTransactionByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ScheduledTransactionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetBudgetSettingsByIdResponse parses an HTTP response from a GetBudgetSettingsByIdWithResponse call
func ParseGetBudgetSettingsByIdResponse(rsp *http.Response) (*GetBudgetSettingsByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBudgetSettingsByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BudgetSettingsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseGetTransactionsResponse parses an HTTP response from a GetTransactionsWithResponse call
func ParseGetTransactionsResponse(rsp *http.Response) (*GetTransactionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTransactionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TransactionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateTransactionsResponse parses an HTTP response from a UpdateTransactionsWithResponse call
func ParseUpdateTransactionsResponse(rsp *http.Response) (*UpdateTransactionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateTransactionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 209:
		var dest SaveTransactionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON209 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseCreateTransactionResponse parses an HTTP response from a CreateTransactionWithResponse call
func ParseCreateTransactionResponse(rsp *http.Response) (*CreateTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest SaveTransactionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseImportTransactionsResponse parses an HTTP response from a ImportTransactionsWithResponse call
func ParseImportTransactionsResponse(rsp *http.Response) (*ImportTransactionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ImportTransactionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TransactionsImportResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest TransactionsImportResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseDeleteTransactionResponse parses an HTTP response from a DeleteTransactionWithResponse call
func ParseDeleteTransactionResponse(rsp *http.Response) (*DeleteTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TransactionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetTransactionByIdResponse parses an HTTP response from a GetTransactionByIdWithResponse call
func ParseGetTransactionByIdResponse(rsp *http.Response) (*GetTransactionByIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTransactionByIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TransactionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}

// ParseUpdateTransactionResponse parses an HTTP response from a UpdateTransactionWithResponse call
func ParseUpdateTransactionResponse(rsp *http.Response) (*UpdateTransactionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateTransactionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TransactionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetUserResponse parses an HTTP response from a GetUserWithResponse call
func ParseGetUserResponse(rsp *http.Response) (*GetUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && true:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSONDefault = &dest

	}

	return response, nil
}
